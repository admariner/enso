import sbt.Keys._
import sbt._
import sbt.internal.util.ManagedLogger
import sbt.io.IO
import sbt.librarymanagement.{ConfigurationFilter, DependencyFilter}

import java.io.File
import java.util.Locale

object StdBits {

  /** Discovers dependencies of a project and copies them into the destination
    * directory.
    *
    * @param destination location where to put the dependencies
    * @param providedJarNames name of JARs generated by the local projects;
    *                         unexpected (old) files are removed, so this task
    *                         needs to know these files' names to avoid removing
    *                         them
    * @param ignoreScalaLibrary whether to ignore Scala dependencies that are
    *                           added by default be SBT and are not relevant in
    *                           pure-Java projects
    * @param ignoreDependency A dependency that should be ignored - not copied to the destination
    * @param ignoreUnmanagedDependency An optional filter that tests if an unmanaged dependency should be ignored
    */
  def copyDependencies(
    destination: File,
    providedJarNames: Seq[String],
    ignoreScalaLibrary: Boolean,
    ignoreDependency: Option[ModuleID]                 = None,
    ignoreUnmanagedDependency: Option[File => Boolean] = None
  ): Def.Initialize[Task[Unit]] =
    Def.task {
      val libraryUpdates = (Compile / update).value
      val log            = streams.value.log

      val baseFilter: NameFilter = new ExactFilter(Configurations.Runtime.name)
      val validConfig =
        if (ignoreScalaLibrary)
          baseFilter - new ExactFilter(Configurations.ScalaTool.name)
        else baseFilter
      val configFilter: ConfigurationFilter =
        DependencyFilter.configurationFilter(name = validConfig)
      val graalVmOrgs = if ("espresso".equals(System.getenv("ENSO_JAVA"))) {
        Seq()
      } else {
        GraalVM.modules.map(_.organization).distinct
      }
      // All graal related modules must be filtered away - they will be provided in
      // module-path, and so, they must not be included in std-bits polyglot directories.
      val graalModuleFilter = DependencyFilter.moduleFilter(
        organization = new SimpleFilter(orgName => {
          !graalVmOrgs.contains(orgName)
        })
      )
      val moduleFilter = ignoreDependency match {
        case None => graalModuleFilter
        case Some(ignoreDepID) =>
          DependencyFilter.moduleFilter(
            organization = new SimpleFilter(orgName => {
              !graalVmOrgs.contains(
                orgName
              ) && orgName != ignoreDepID.organization
            }),
            name = new SimpleFilter(nm => {
              nm != ignoreDepID.name
            })
          )
      }
      val unmanagedFiles0 = (Compile / unmanagedJars).value.map(_.data)
      val unmanagedFiles = ignoreUnmanagedDependency
        .map(fun => unmanagedFiles0.filterNot(fun))
        .getOrElse(unmanagedFiles0)
      val relevantFiles =
        libraryUpdates
          .select(
            configuration = configFilter,
            module        = moduleFilter,
            artifact      = DependencyFilter.artifactFilter()
          ) ++ unmanagedFiles
      val dependencyStore =
        streams.value.cacheStoreFactory.make("std-bits-dependencies")
      Tracked.diffInputs(dependencyStore, FileInfo.hash)(relevantFiles.toSet) {
        report =>
          val expectedFileNames =
            report.checked.map(file => file.getName) ++ providedJarNames
          for (existing <- IO.listFiles(destination)) {
            if (!expectedFileNames.contains(existing.getName)) {
              log.info(
                s"Removing outdated std-bits dependency ${existing.getName}."
              )
              IO.delete(existing)
            }
          }
          for (changed <- report.modified -- report.removed) {
            log.info(
              s"Updating changed std-bits dependency ${changed.getName}."
            )
            updateDependency(changed, destination, log)
          }
          for (file <- report.unmodified) {
            val dest = destination / file.getName
            if (!dest.exists()) {
              log.info(s"Adding missing std-bits dependency ${file.getName}.")
              updateDependency(file, destination, log)
            }
          }
      }
    }

  /** Extract native libraries from `opencv.jar` and put them under
    * `Standard/Image/polyglot/lib` directory. The minimized `opencv.jar` will
    * be put under `Standard/Image/polyglot/java` directory.
    * @param imagePolyglotRoot root dir of Std image polyglot dir
    * @param imageNativeLibs root dir of Std image lib dir
    * @return
    */
  def extractNativeLibsFromOpenCV(
    imagePolyglotRoot: File,
    imageNativeLibs: File,
    opencvVersion: String
  ): Def.Initialize[Task[Unit]] = Def.task {

    val extractPrefix = "nu/pattern/opencv"
    val validOsName   = osName()
    val validArch     = arch()

    // Make sure that the native libs in the `lib` directory complies with
    // `org.enso.interpreter.runtime.NativeLibraryFinder`
    def renameFunc(entryName: String): Option[String] = {
      val strippedEntryName = entryName
        .substring(extractPrefix.length + 1)
        .replace("ARMv8", "aarch64")
      if (
        strippedEntryName.contains("linux/ARM") ||
        strippedEntryName.contains("linux/x86_32") ||
        strippedEntryName.contains("README.md")    ||
        // Remove native libs for different platforms
        !strippedEntryName.contains(validOsName) ||
        !strippedEntryName.contains(validArch)
      ) {
        None
      } else {
        Some(
          strippedEntryName
            .replace("linux/x86_64", "amd64")
            .replace("windows/x86_64", "amd64")
            .replace("windows/x86_32", "x86_32")
            .replace("osx/aarch64", "aarch64")
            .replace("osx/x86_64", "amd64")
        )
      }
    }

    val logger = streams.value.log
    val openCvJar = JPMSUtils
      .filterModulesFromUpdate(
        update.value,
        Seq("org.openpnp" % "opencv" % opencvVersion),
        logger,
        moduleName.value,
        scalaBinaryVersion.value,
        shouldContainAll = true
      )
      .head
    val outputJarPath     = (imagePolyglotRoot / "opencv.jar").toPath
    val extractedFilesDir = imageNativeLibs.toPath
    JARUtils.extractFilesFromJar(
      openCvJar.toPath,
      Some(extractPrefix),
      Some(outputJarPath),
      extractedFilesDir,
      renameFunc,
      logger,
      streams.value.cacheStoreFactory
    )
  }

  /** Extract native libraries from `tableauhyperapi-<osname>.jar` and put them under
    * `Standard/Tableau/polyglot/lib` directory.
    * @param tableauPolyglotRoot root dir of Std tableau polyglot dir
    * @param tableauNativeLibs root dir of Std tableau lib dir
    * @return
    */
  def extractNativeLibsFromTableau(
    tableauPolyglotRoot: File,
    tableauNativeLibs: File,
    tableauVersion: String,
    jnaVersion: String
  ): Def.Initialize[Task[Unit]] = Def.task {

    val validOsName = osName(unixName = true)
    val validOsExt  = osExt()
    val validArch   = arch().replace("_", "-")
    // Make sure that the native libs in the `lib` directory complies with
    // `org.enso.interpreter.runtime.NativeLibraryFinder`
    def renameFunc(prefix: String)(entryName: String): Option[String] = {
      val strippedEntryName =
        (if (prefix.isEmpty) entryName
         else entryName.substring(prefix.length + 1)).replace("jnilib", "dylib")
      if (strippedEntryName.contains(validOsExt)) {
        println("RENAME: " + strippedEntryName)
      }
      if (
        !strippedEntryName.endsWith(validOsExt) ||
        // Remove native libs for different platforms
        !strippedEntryName.contains(validOsName) ||
        !strippedEntryName.contains(validArch)
      ) {
        None
      } else {
        println("INCLUDE? " + strippedEntryName)
        Some(
          strippedEntryName
            .replace("linux-x86-64", "amd64")
            .replace("win32-x86-64", "amd64")
            .replace("darwin-aarch64", "aarch64")
            .replace("darwin-x86-64", "amd64")
        )
      }
    }

    // Extract native library from tableauhyperapi-$arch's jar
    val tableauSuffixInJar = s"tableauhyperapi-${plainOsName()}"
    val tableauNativeLibJar = (Compile / unmanagedJars).value
      .map(_.data)
      .filter(f => f.getName.contains(tableauSuffixInJar))
      .head
    val logger = streams.value.log

    val extractedFilesDir = tableauNativeLibs.toPath
    JARUtils.extractFilesFromJar(
      tableauNativeLibJar.toPath,
      None,
      None,
      extractedFilesDir,
      renameFunc(""),
      logger,
      streams.value.cacheStoreFactory
    )

    // Extract native library from jna's jar
    val jnaJar = JPMSUtils
      .filterModulesFromUpdate(
        update.value,
        Seq("net.java.dev.jna" % "jna" % jnaVersion),
        logger,
        moduleName.value,
        scalaBinaryVersion.value,
        shouldContainAll = true
      )
      .head
    val outputJnaJarPath = (tableauPolyglotRoot / s"jna-$jnaVersion.jar").toPath
    val extractPrefix    = "com/sun/jna"
    JARUtils.extractFilesFromJar(
      jnaJar.toPath,
      Some(extractPrefix),
      Some(outputJnaJarPath),
      extractedFilesDir,
      renameFunc(extractPrefix),
      logger,
      streams.value.cacheStoreFactory,
      cleanOutputDirs = false
    )
  }

  /** Inspired by `org.enso.pkg.NativeLibraryFinder`
    */
  private def osName(unixName: Boolean = false): String = {
    var osName = System.getProperty("os.name").toLowerCase(Locale.ENGLISH)
    if (osName.contains(" ")) {
      // Strip version
      osName = osName.substring(0, osName.indexOf(' '))
    }
    if (osName.contains("linux")) {
      "linux"
    } else if (osName.contains("mac")) {
      if (unixName) "darwin" else "osx"
    } else if (osName.contains("windows")) {
      if (unixName) "win32" else "windows"
    } else {
      throw new IllegalStateException(s"Unsupported OS: $osName")
    }
  }

  // Human-accepted name of OS. One of many at least.
  private def plainOsName(): String = {
    var osName = System.getProperty("os.name").toLowerCase(Locale.ENGLISH)
    if (osName.contains(" ")) {
      // Strip version
      osName = osName.substring(0, osName.indexOf(' '))
    }
    if (osName.contains("linux")) {
      "linux"
    } else if (osName.contains("mac")) {
      "macos"
    } else if (osName.contains("windows")) {
      "windows"
    } else {
      throw new IllegalStateException(s"Unsupported OS: $osName")
    }
  }

  private def osExt(): String = {
    var osName = System.getProperty("os.name").toLowerCase(Locale.ENGLISH)
    if (osName.contains(" ")) {
      // Strip version
      osName = osName.substring(0, osName.indexOf(' '))
    }
    if (osName.contains("linux")) {
      ".so"
    } else if (osName.contains("mac")) {
      ".dylib"
    } else if (osName.contains("windows")) {
      ".dll"
    } else {
      throw new IllegalStateException(s"Unsupported OS: $osName")
    }
  }

  /** Inspired by `org.enso.pkg.NativeLibraryFinder`
    */
  private def arch(): String = {
    val arch = System.getProperty("os.arch").toLowerCase(Locale.ENGLISH)
    arch
      .replace("amd64", "x86_64")
  }

  private def updateDependency(
    jar: File,
    destinationDir: File,
    logger: ManagedLogger
  ): Unit = {
    val destination = destinationDir / jar.getName
    IO.copyFile(jar, destination)
  }

  /** Builds a single standard library package `name`. Should only be used
    * in tasks used in local development.
    *
    * @param name name of the package, see `stdBitsProjects` in build.sbt
    * @param root top directory where distribution is being built
    * @param cache used for persisting the cached information
    * @param log logger used in the task
    * @param defaultDevEnsoVersion default `dev` version
    */
  def buildStdLibPackage(
    name: String,
    root: File,
    cacheFactory: sbt.util.CacheStoreFactory,
    log: sbt.Logger,
    defaultDevEnsoVersion: String
  ) = {
    log.info(s"Building standard library package for '$name'")
    val prefix        = "Standard"
    val targetPkgRoot = root / "lib" / prefix / name / defaultDevEnsoVersion
    val sourceDir = file(
      s"distribution/lib/$prefix/$name/$defaultDevEnsoVersion"
    )
    if (!sourceDir.exists) {
      throw new RuntimeException("Invalid standard library package " + name)
    }
    val result = DistributionPackage.copyDirectoryIncremental(
      source      = file(s"distribution/lib/$prefix/$name/$defaultDevEnsoVersion"),
      destination = targetPkgRoot,
      cache       = cacheFactory.sub("engine-libraries").make(s"$prefix.$name")
    )
    if (result) {
      log.info(s"Package '$name' has been updated")
    } else {
      log.info(s"No changes detected for '$name' package")
    }
  }

}
