from Standard.Base import all
from Standard.Test import all
from Standard.Table import all

from Standard.Database.Errors import Unsupported_Database_Operation
import Standard.Database.Feature.Feature
from Standard.Base.Errors.Common import Missing_Argument, Floating_Point_Equality
from Standard.Table.Errors import Missing_Input_Columns

from project.Common_Table_Operations.Util import run_default_backend
import project.Common_Table_Operations.Util
import project.Util as Test_Utils

main filter=Nothing = run_default_backend add_specs filter

add_specs suite_builder setup =
    if setup.is_feature_supported Feature.Offset then (add_offset_specs suite_builder setup) else
        suite_builder.group setup.prefix+"Table.offset" group_builder->
            group_builder.specify "offset should report unsupported" <|
                table_builder = setup.light_table_builder
                t = table_builder [["ix", [1, 2, 3, 4, 5]], ["X", [100, 3, Nothing, 4, 12]], ["Y", [100, 4, 2, Nothing, 11]]]
                t2 = t.offset ["X"]
                t2.should_fail_with (Unsupported_Database_Operation.Error "offset")
                c = t.at 0
                c2 = c.offset
                c2.should_fail_with (Unsupported_Database_Operation.Error "offset")

add_offset_specs suite_builder setup =
    prefix = setup.prefix
    build_sorted_table = Util.build_sorted_table setup
    t = build_sorted_table [["A", [1, 2, 3]], ["B", [Nothing, Nothing, Nothing], Value_Type.Integer], ["Text Values", ["A", "B", "C"]]]
    c = t.at 0 
    c_nothings = t.at 1
    c_zero_rows = t.take 0 . at 0
    if setup.is_database then suite_builder.group prefix+"Column.Offset does not work in database" group_builder->
        group_builder.specify "Gives an error message" <|
            r = c.offset
            ## TODO - Ideally this should have a custome error message telling users to use Table.offset
            r.should_fail_with (Unsupported_Database_Operation.Error "offset")
    if setup.is_database.not then suite_builder.group prefix+"Column.Offset with default fill strategy" group_builder->
        group_builder.specify "Works with default values" <|
            r = c.offset
            r.to_vector . should_equal [Nothing, 1, 2]
            r.name . should_equal "offset([A], -1, Fill_With.Nothing)"
        group_builder.specify "Negative n shifts the values down" <|
            r = c.offset -1
            r.to_vector . should_equal [Nothing, 1, 2]
        group_builder.specify "Positive n shifts the values up" <|
            r = c.offset 1
            r.to_vector . should_equal [2, 3, Nothing]
        group_builder.specify "Zero n is a no-op" <|
            r = c.offset 0
            r.to_vector . should_equal [1, 2, 3]
        group_builder.specify "Large negative n values work" <|
            r = c.offset -1024
            r.to_vector . should_equal [Nothing, Nothing, Nothing]
        group_builder.specify "Large positive n values work" <|
            r = c.offset 1024
            r.to_vector . should_equal [Nothing, Nothing, Nothing]
        group_builder.specify "Works with zero rows" <|
            r = c_zero_rows.offset
            r.to_vector . should_equal []
    if setup.is_database.not then suite_builder.group prefix+"Column.Offset with closest value fill strategy" group_builder->
        group_builder.specify "Negative n shifts the values down" <|
            r = c.offset -1 ..Closest_Value
            r.to_vector . should_equal [1, 1, 2]
        group_builder.specify "Positive n shifts the values up" <|
            r = c.offset 1 ..Closest_Value
            r.to_vector . should_equal [2, 3, 3]
        group_builder.specify "Zero n is a no-op" <|
            r = c.offset 0 ..Closest_Value
            r.to_vector . should_equal [1, 2, 3]
        group_builder.specify "Large negative n values work" <|
            r = c.offset -1024 ..Closest_Value
            r.to_vector . should_equal [1, 1, 1]
        group_builder.specify "Large positive n values work" <|
            r = c.offset 1024 ..Closest_Value
            r.to_vector . should_equal [3, 3, 3]
        group_builder.specify "Works with zero rows" <|
            r = c_zero_rows.offset -1 ..Closest_Value
            r.to_vector . should_equal []
        group_builder.specify "Works with negative n and column of nothings" <|
            r = c_nothings.offset -1 ..Closest_Value
            r.to_vector . should_equal [Nothing, Nothing, Nothing]
        group_builder.specify "Works with positive n and column of nothings" <|
            r = c_nothings.offset 1 ..Closest_Value
            r.to_vector . should_equal [Nothing, Nothing, Nothing]
    if setup.is_database.not then suite_builder.group prefix+"Column.Offset with wrap around fill strategy" group_builder->
        group_builder.specify "Negative n shifts the values down" <|
            r = c.offset -1 ..Wrap_Around
            r.to_vector . should_equal [3, 1, 2]
        group_builder.specify "Positive n shifts the values up" <|
            r = c.offset 1 ..Wrap_Around
            r.to_vector . should_equal [2, 3, 1]
        group_builder.specify "Continues to wrap around after n is bigger than number of rows (negative n)" <|
            r = c.offset -4 ..Wrap_Around
            r.to_vector . should_equal [3, 1, 2]
        group_builder.specify "Continues to wrap around after n is bigger than number of rows (positive n)" <|
            r = c.offset 4 ..Wrap_Around
            r.to_vector . should_equal [2, 3, 1]
        group_builder.specify "Zero n is a no-op" <|
            r = c.offset 0 ..Wrap_Around
            r.to_vector . should_equal [1, 2, 3]
        group_builder.specify "Large negative n values work" <|
            r = c.offset -1024 ..Wrap_Around
            r.to_vector . should_equal [3, 1, 2]
        group_builder.specify "Large positive n values work" <|
            r = c.offset 1024 ..Wrap_Around
            r.to_vector . should_equal [2, 3, 1]
        group_builder.specify "Works with zero rows" <|
            r = c_zero_rows.offset -1 ..Wrap_Around
            r.to_vector . should_equal []
        group_builder.specify "Works with negative n and column of nothings" <|
            r = c_nothings.offset -1 ..Wrap_Around
            r.to_vector . should_equal [Nothing, Nothing, Nothing]
        group_builder.specify "Works with positive n and column of nothings" <|
            r = c_nothings.offset 1 ..Wrap_Around
            r.to_vector . should_equal [Nothing, Nothing, Nothing]
    if setup.is_database.not then suite_builder.group prefix+"Column.Offset with constant fill strategy" pending="TODO - constant fill strategy" group_builder->
        group_builder.specify "Negative n shifts the values down" <|
            r = c.offset -1 42
            r.to_vector . should_equal [42, 1, 2]
        group_builder.specify "Positive n shifts the values up" <|
            r = c.offset 1 42
            r.to_vector . should_equal [2, 3, 42]
        group_builder.specify "Zero n is a no-op" <|
            r = c.offset 0 42
            r.to_vector . should_equal [1, 2, 3]
        group_builder.specify "Large negative n values work" <|
            r = c.offset -1024 42
            r.to_vector . should_equal [42, 42, 42]
        group_builder.specify "Large positive n values work" <|
            r = c.offset 1024 42
            r.to_vector . should_equal [42, 42, 42]
        group_builder.specify "Works with zero rows" <|
            r = c_zero_rows.offset -1 42
            r.to_vector . should_equal []
        group_builder.specify "Works with negative n and column of nothings" <|
            r = c_nothings.offset -1 42
            r.to_vector . should_equal [42, Nothing, Nothing]
        group_builder.specify "Works with positive n and column of nothings" <|
            r = c_nothings.offset 1 42
            r.to_vector . should_equal [Nothing, Nothing, 42]
        group_builder.specify "Can create mixed colums" <|
            r = c.offset -1 "42"
            r.to_vector . should_equal ["42", 1, 2]
    if setup.is_database.not then suite_builder.group prefix+"Works in Table.set expressions with default" group_builder->
        group_builder.specify "Works with default values" <|
            r = t.set (expr 'offset([A])') . at "offset([A])"
            r.to_vector . should_equal [Nothing, 1, 2]
        group_builder.specify "Negative n shifts the values down" <|
            r = t.set (expr 'offset([A], -1)')  . at "offset([A], -1)"
            r.to_vector . should_equal [Nothing, 1, 2]
        group_builder.specify "Positive n shifts the values up" <|
            r = t.set (expr 'offset([A], 1)')  . at "offset([A], 1)"
            r.to_vector . should_equal [2, 3, Nothing]
        group_builder.specify "Zero n is a no-op" <|
            r = t.set (expr 'offset([A], 0)')  . at "offset([A], 0)"
            r.to_vector . should_equal [1, 2, 3]
        group_builder.specify "Large negative n values work" <|
            r = t.set (expr 'offset([A], -1024)')  . at "offset([A], -1024)"
            r.to_vector . should_equal [Nothing, Nothing, Nothing]
        group_builder.specify "Large positive n values work" <|
            r = t.set (expr 'offset([A], 1024)')  . at "offset([A], 1024)"
            r.to_vector . should_equal [Nothing, Nothing, Nothing]
    suite_builder.group prefix+"Table.Offset with default fill strategy" group_builder->
        colA = ["A", [1, 2, 3]]
        t1 = build_sorted_table [colA]
        group_builder.specify "Works with default values" <|
            t1.offset ["A"] . should_equal ignore_order=setup.is_database
                Table.new [colA, ["offset([A], -1, Fill_With.Nothing)", [Nothing, 1, 2]]]
        group_builder.specify "Works with negative n values" <|
            t1.offset ["A"] -2 . should_equal ignore_order=setup.is_database
                Table.new [colA, ["offset([A], -2, Fill_With.Nothing)", [Nothing, Nothing, 1]]]
        group_builder.specify "Works with positive n values (n=1)" <|
            t1.offset ["A"] 1 . should_equal ignore_order=setup.is_database
                Table.new [colA, ["offset([A], 1, Fill_With.Nothing)", [2, 3, Nothing]]]
        group_builder.specify "Works with positive n values (n=2)" <|
            t1.offset ["A"] 2 . should_equal ignore_order=setup.is_database
                Table.new [colA, ["offset([A], 2, Fill_With.Nothing)", [3, Nothing, Nothing]]]
        group_builder.specify "Zero n is a no-op" <|
            t1.offset ["A"] 0 . should_equal ignore_order=setup.is_database
                Table.new [colA, ["offset([A], 0, Fill_With.Nothing)" , [1, 2, 3]]]
        group_builder.specify "Large negative n values work" <|
            t1.offset ["A"] -1024 . should_equal ignore_order=setup.is_database
                Table.new [colA, ["offset([A], -1024, Fill_With.Nothing)", [Nothing, Nothing, Nothing], Value_Type.Integer]]
        group_builder.specify "Large positive n values work" <|
            t1.offset ["A"] 1024 . should_equal ignore_order=setup.is_database
                Table.new [colA, ["offset([A], 1024, Fill_With.Nothing)", [Nothing, Nothing, Nothing], Value_Type.Integer]]
        group_builder.specify "Works with zero rows" <|
            build_sorted_table [["A",[], Value_Type.Integer],["B",[], Value_Type.Integer]] . sort ["B"] . offset ["A"] -1 . should_equal ignore_order=setup.is_database
                Table.new [["A", [], Value_Type.Integer], ["B", [], Value_Type.Integer], ["offset([A], -1, Fill_With.Nothing)", [], Value_Type.Integer]]
    suite_builder.group prefix+"Table.Offset with default fill strategy (Text Values)" group_builder->
        colText = ["Text Values", ["A", "B", "C"]]
        t1 = build_sorted_table [colText]
        group_builder.specify "Works with default values" <|
            t1.offset ["Text Values"] . should_equal ignore_order=setup.is_database
                Table.new [colText, ["offset([Text Values], -1, Fill_With.Nothing)", [Nothing, "A", "B"]]]
        group_builder.specify "Works with negative n values" <|
            t1.offset ["Text Values"] -2 . should_equal ignore_order=setup.is_database
                Table.new [colText, ["offset([Text Values], -2, Fill_With.Nothing)", [Nothing, Nothing, "A"]]]
        group_builder.specify "Works with positive n values (n=1)" <|
            t1.offset ["Text Values"] 1 . should_equal ignore_order=setup.is_database
                Table.new [colText, ["offset([Text Values], 1, Fill_With.Nothing)", ["B", "C", Nothing]]]
        group_builder.specify "Works with positive n values (n=2)" <|
            t1.offset ["Text Values"] 2 . should_equal ignore_order=setup.is_database
                Table.new [colText, ["offset([Text Values], 2, Fill_With.Nothing)", ["C", Nothing, Nothing]]]
    suite_builder.group prefix+"Table.Offset with closest value fill strategy" group_builder->
        colA = ["A", [1, 2, 3]]
        colB = ["B", [Nothing, Nothing, Nothing], Value_Type.Integer]
        t1 = build_sorted_table [colA, colB]
        group_builder.specify "Negative n shifts the values down" <|
            t1.offset ["A"] -1 ..Closest_Value . should_equal ignore_order=setup.is_database
                Table.new [colA, colB, ["offset([A], -1, Fill_With.Closest_Value)", [1, 1, 2]]]
        group_builder.specify "Positive n shifts the values up" <|
            t1.offset ["A"] 1 ..Closest_Value . should_equal ignore_order=setup.is_database
                Table.new [colA, colB, ["offset([A], 1, Fill_With.Closest_Value)", [2, 3, 3]]]
        group_builder.specify "Zero n is a no-op" <|
            t1.offset ["A"] 0 ..Closest_Value . should_equal ignore_order=setup.is_database
                Table.new [colA, colB, ["offset([A], 0, Fill_With.Closest_Value)", [1, 2, 3]]]
        group_builder.specify "Large negative n values work" <|
            t1.offset ["A"] -1024 ..Closest_Value . should_equal ignore_order=setup.is_database
                Table.new [colA, colB, ["offset([A], -1024, Fill_With.Closest_Value)", [1, 1, 1]]]
        group_builder.specify "Large positive n values work" <|
            t1.offset ["A"] 1024 ..Closest_Value . should_equal ignore_order=setup.is_database
                Table.new [colA, colB, ["offset([A], 1024, Fill_With.Closest_Value)", [3, 3, 3]]]
        group_builder.specify "Works with zero rows" <|
            build_sorted_table [["A",[], Value_Type.Integer],["B",[], Value_Type.Integer]] . sort ["B"] . offset ["A"] -1 ..Closest_Value . should_equal ignore_order=setup.is_database
                Table.new [["A", [], Value_Type.Integer], ["B", [], Value_Type.Integer], ["offset([A], -1, Fill_With.Closest_Value)", [], Value_Type.Integer]]
        group_builder.specify "Works with negative n and column of nothings" <|
            t1.offset ["B"] -1 ..Closest_Value . should_equal ignore_order=setup.is_database
                Table.new [colA, colB, ["offset([B], -1, Fill_With.Closest_Value)", [Nothing, Nothing, Nothing], Value_Type.Integer]]
        group_builder.specify "Works with positive n and column of nothings" <|
            t1.offset ["B"] 1 ..Closest_Value . should_equal ignore_order=setup.is_database
                Table.new [colA, colB, ["offset([B], 1, Fill_With.Closest_Value)", [Nothing, Nothing, Nothing], Value_Type.Integer]]
    if setup.is_database then suite_builder.group prefix+"Table.Offset with wrap around fill strategy" group_builder->
        colA = ["A", [1, 2, 3]]
        colB = ["B", [Nothing, Nothing, Nothing], Value_Type.Integer]
        t1 = build_sorted_table [colA, colB]
        group_builder.specify "Reports unsupported for in database" <|
            r = t1.offset ["A"] -1 ..Wrap_Around
            r.should_fail_with (Unsupported_Database_Operation.Error "offset with Fill_With.Wrap_Around")
    if setup.is_database.not then suite_builder.group prefix+"Table.Offset with wrap around fill strategy" group_builder->
        colA = ["A", [1, 2, 3]]
        colB = ["B", [Nothing, Nothing, Nothing], Value_Type.Integer]
        t1 = build_sorted_table [colA, colB]
        group_builder.specify "Negative n shifts the values down" <|
            t1.offset ["A"] -1 ..Wrap_Around . should_equal ignore_order=setup.is_database
                Table.new [colA, colB, ["offset([A], -1, Fill_With.Wrap_Around)", [3, 1, 2]]]
        group_builder.specify "Positive n shifts the values up" <|
            t1.offset ["A"] 1 ..Wrap_Around . should_equal ignore_order=setup.is_database
                Table.new [colA, colB, ["offset([A], 1, Fill_With.Wrap_Around)", [2, 3, 1]]]
        group_builder.specify "Negative n shifts the values down (n=2)" <|
            t1.offset ["A"] -2 ..Wrap_Around . should_equal ignore_order=setup.is_database
                Table.new [colA, colB, ["offset([A], -2, Fill_With.Wrap_Around)", [2, 3, 1]]]
        group_builder.specify "Positive n shifts the values up (n=2)" <|
            t1.offset ["A"] 2 ..Wrap_Around . should_equal ignore_order=setup.is_database
                Table.new [colA, colB, ["offset([A], 2, Fill_With.Wrap_Around)", [3, 1, 2]]]
        group_builder.specify "Zero n is a no-op" <|
            t1.offset ["A"] 0 ..Wrap_Around . should_equal ignore_order=setup.is_database
                Table.new [colA, colB, ["offset([A], 0, Fill_With.Wrap_Around)", [1, 2, 3]]]
        group_builder.specify "Larger than num rows negative n values work" <|
            t1.offset ["A"] -4 ..Wrap_Around . should_equal ignore_order=setup.is_database
                Table.new [colA, colB, ["offset([A], -4, Fill_With.Wrap_Around)", [3, 1, 2]]]
        group_builder.specify "Larger than num rows positive n values work" <|
            t1.offset ["A"] 4 ..Wrap_Around . should_equal ignore_order=setup.is_database
                Table.new [colA, colB, ["offset([A], 4, Fill_With.Wrap_Around)", [2, 3, 1]]]
        group_builder.specify "Large negative n values work" <|
            t1.offset ["A"] -1024 ..Wrap_Around . should_equal ignore_order=setup.is_database
                Table.new [colA, colB, ["offset([A], -1024, Fill_With.Wrap_Around)", [3, 1, 2]]]
        group_builder.specify "Large positive n values work" <|
            t1.offset ["A"] 1024 ..Wrap_Around . should_equal ignore_order=setup.is_database
                Table.new [colA, colB, ["offset([A], 1024, Fill_With.Wrap_Around)", [2, 3, 1]]]
        group_builder.specify "Works with zero rows" <|
            build_sorted_table [["A",[], Value_Type.Integer],["B",[], Value_Type.Integer]] . sort ["B"] . offset ["A"] -1 ..Wrap_Around . should_equal ignore_order=setup.is_database
                Table.new [["A", [], Value_Type.Integer], ["B", [], Value_Type.Integer], ["offset([A], -1, Fill_With.Wrap_Around)", [], Value_Type.Integer]]
        group_builder.specify "Works with negative n and column of nothings" <|
            t1.offset ["B"] -1 ..Wrap_Around . should_equal ignore_order=setup.is_database
                Table.new [colA, colB, ["offset([B], -1, Fill_With.Wrap_Around)", [Nothing, Nothing, Nothing], Value_Type.Integer]]
        group_builder.specify "Works with positive n and column of nothings" <|
            t1.offset ["B"] 1 ..Wrap_Around . should_equal ignore_order=setup.is_database
                Table.new [colA, colB, ["offset([B], 1, Fill_With.Wrap_Around)", [Nothing, Nothing, Nothing], Value_Type.Integer]]
    suite_builder.group prefix+"Table.Offset works with grouping - default fill strategy" group_builder->
        groupColumn = ["Group", ["A", "A", "A", "B", "B", "B", "B", "C", "C"]]
        dataCol = ["Col", [1, 2, 3, 1, 2, 3, 4, 1, 2]]
        t2 = build_sorted_table [groupColumn, dataCol]
        group_builder.specify "Negative n shifts the values down" <|
            t2.offset ["Col"] -1 ..Nothing group_by=["Group"] . should_equal ignore_order=setup.is_database
                Table.new [groupColumn, dataCol, ["offset([Col], -1, Fill_With.Nothing)", [Nothing, 1, 2, Nothing, 1, 2, 3, Nothing, 1]]]
        group_builder.specify "Positive n shifts the values up" <|
            t2.offset ["Col"] 1 ..Nothing group_by=["Group"] . should_equal ignore_order=setup.is_database
                Table.new [groupColumn, dataCol, ["offset([Col], 1, Fill_With.Nothing)", [2, 3, Nothing, 2, 3, 4, Nothing, 2, Nothing]]]
        group_builder.specify "Negative n shifts the values down (n=2)" <|
            t2.offset ["Col"] -2 ..Nothing group_by=["Group"] . should_equal ignore_order=setup.is_database
                Table.new [groupColumn, dataCol, ["offset([Col], -2, Fill_With.Nothing)", [Nothing, Nothing, 1, Nothing, Nothing, 1, 2, Nothing, Nothing]]]
        group_builder.specify "Positive n shifts the values up (n=2)" <|
            t2.offset ["Col"] 2 ..Nothing group_by=["Group"] . should_equal ignore_order=setup.is_database
                Table.new [groupColumn, dataCol, ["offset([Col], 2, Fill_With.Nothing)", [3, Nothing, Nothing, 3, 4, Nothing, Nothing, Nothing, Nothing]]]
        group_builder.specify "Zero n is a no-op" <|
            t2.offset ["Col"] 0 ..Nothing group_by=["Group"] . should_equal ignore_order=setup.is_database
                Table.new [groupColumn, dataCol, ["offset([Col], 0, Fill_With.Nothing)", [1, 2, 3, 1, 2, 3, 4, 1, 2]]]
        group_builder.specify "Large negative n values work" <|
            t2.offset ["Col"] -1024 ..Nothing group_by=["Group"] . should_equal ignore_order=setup.is_database
                Table.new [groupColumn, dataCol, ["offset([Col], -1024, Fill_With.Nothing)", [Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing], Value_Type.Integer]]
        group_builder.specify "Large positive n values work" <|
            t2.offset ["Col"] 1024 ..Nothing group_by=["Group"] . should_equal ignore_order=setup.is_database
                Table.new [groupColumn, dataCol, ["offset([Col], 1024, Fill_With.Nothing)", [Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing], Value_Type.Integer]]
    suite_builder.group prefix+"Table.Offset works with grouping - closest fill strategy" group_builder->
        groupColumn = ["Group", ["A", "A", "A", "B", "B", "B", "B", "C", "C"]]
        dataCol = ["Col", [1, 2, 3, 10, 20, 30, 40, 100, 200]]
        t2 = build_sorted_table [groupColumn, dataCol]
        group_builder.specify "Negative n shifts the values down" <|
            t2.offset ["Col"] -1 ..Closest_Value group_by=["Group"] . should_equal ignore_order=setup.is_database
                Table.new [groupColumn, dataCol, ["offset([Col], -1, Fill_With.Closest_Value)", [1, 1, 2, 10, 10, 20, 30, 100, 100]]]
        group_builder.specify "Positive n shifts the values up" <|
            t2.offset ["Col"] 1 ..Closest_Value group_by=["Group"] . should_equal ignore_order=setup.is_database
                Table.new [groupColumn, dataCol, ["offset([Col], 1, Fill_With.Closest_Value)", [2, 3, 3, 20, 30, 40, 40, 200, 200]]]
        group_builder.specify "Negative n shifts the values down (n=2)" <|
            t2.offset ["Col"] -2 ..Closest_Value group_by=["Group"] . should_equal ignore_order=setup.is_database
                Table.new [groupColumn, dataCol, ["offset([Col], -2, Fill_With.Closest_Value)", [1, 1, 1, 10, 10, 10, 20, 100, 100]]]
        group_builder.specify "Positive n shifts the values up (n=2)" <|
            t2.offset ["Col"] 2 ..Closest_Value group_by=["Group"] . should_equal ignore_order=setup.is_database
                Table.new [groupColumn, dataCol, ["offset([Col], 2, Fill_With.Closest_Value)", [3, 3, 3, 30, 40, 40, 40, 200, 200]]]
        group_builder.specify "Zero n is a no-op" <|
            t2.offset ["Col"] 0 ..Closest_Value group_by=["Group"] . should_equal ignore_order=setup.is_database
                Table.new [groupColumn, dataCol, ["offset([Col], 0, Fill_With.Closest_Value)", [1, 2, 3, 10, 20, 30, 40, 100, 200]]]
        group_builder.specify "Large negative n values work" <|
            t2.offset ["Col"] -1024 ..Closest_Value group_by=["Group"] . should_equal ignore_order=setup.is_database
                Table.new [groupColumn, dataCol, ["offset([Col], -1024, Fill_With.Closest_Value)", [1, 1, 1, 10, 10, 10, 10, 100, 100]]]
        group_builder.specify "Large positive n values work" <|
            t2.offset ["Col"] 1024 ..Closest_Value group_by=["Group"] . should_equal ignore_order=setup.is_database
                Table.new [groupColumn, dataCol, ["offset([Col], 1024, Fill_With.Closest_Value)", [3, 3, 3, 40, 40, 40, 40, 200, 200]]]
    if setup.is_database.not then suite_builder.group prefix+"Table.Offset works with grouping - wrap around fill strategy" group_builder->
        groupColumn = ["Group", ["A", "A", "A", "B", "B", "B", "B", "C", "C"]]
        dataCol = ["Col", [1, 2, 3, 1, 2, 3, 4, 1, 2]]
        t2 = build_sorted_table [groupColumn, dataCol]
        group_builder.specify "Negative n shifts the values down" <|
            t2.offset ["Col"] -1 ..Wrap_Around group_by=["Group"] . should_equal ignore_order=setup.is_database
                Table.new [groupColumn, dataCol, ["offset([Col], -1, Fill_With.Wrap_Around)", [3, 1, 2, 4, 1, 2, 3, 2, 1]]]
        group_builder.specify "Positive n shifts the values up" <|
            t2.offset ["Col"] 1 ..Wrap_Around group_by=["Group"] . should_equal ignore_order=setup.is_database
                Table.new [groupColumn, dataCol, ["offset([Col], 1, Fill_With.Wrap_Around)", [2, 3, 1, 2, 3, 4, 1, 2, 1]]]
        group_builder.specify "Negative n shifts the values down (n=2)" <|
            t2.offset ["Col"] -2 ..Wrap_Around group_by=["Group"] . should_equal ignore_order=setup.is_database
                Table.new [groupColumn, dataCol, ["offset([Col], -2, Fill_With.Wrap_Around)", [2, 3, 1, 3, 4, 1, 2, 1, 2]]]
        group_builder.specify "Positive n shifts the values up (n=2)" <|
            t2.offset ["Col"] 2 ..Wrap_Around group_by=["Group"] . should_equal ignore_order=setup.is_database
                Table.new [groupColumn, dataCol, ["offset([Col], 2, Fill_With.Wrap_Around)", [3, 1, 2, 3, 4, 1, 2, 1, 2]]]
        group_builder.specify "Zero n is a no-op" <|
            t2.offset ["Col"] 0 ..Wrap_Around group_by=["Group"] . should_equal ignore_order=setup.is_database
                Table.new [groupColumn, dataCol, ["offset([Col], 0, Fill_With.Wrap_Around)", [1, 2, 3, 1, 2, 3, 4, 1, 2]]]
        group_builder.specify "Large negative n values work" <|
            t2.offset ["Col"] -1022 ..Wrap_Around group_by=["Group"] . should_equal ignore_order=setup.is_database
                Table.new [groupColumn, dataCol, ["offset([Col], -1022, Fill_With.Wrap_Around)", [2, 3, 1, 3, 4, 1, 2, 1, 2]]]
        group_builder.specify "Large positive n values work" <|
            t2.offset ["Col"] 1022 ..Wrap_Around group_by=["Group"] . should_equal ignore_order=setup.is_database
                Table.new [groupColumn, dataCol, ["offset([Col], 1022, Fill_With.Wrap_Around)", [3, 1, 2, 3, 4, 1, 2, 1, 2]]]
    suite_builder.group prefix+"Table.Offset works with ordering - default fill strategy" group_builder->
        orderColumn = ["Order", [1, 4, 2, 5, 3]]
        dataCol = ["Col", ["A", "D", "B", "E", "C"]]
        t2 = build_sorted_table [orderColumn, dataCol]
        group_builder.specify "Negative n shifts the values down" <|
            t2.offset ["Col"] -1 ..Nothing order_by=["Order"] . should_equal ignore_order=setup.is_database
                Table.new [orderColumn, dataCol, ["offset([Col], -1, Fill_With.Nothing)", [Nothing, "C", "A", "D", "B"]]]
        group_builder.specify "Positive n shifts the values up" <|
            t2.offset ["Col"] 1 ..Nothing order_by=["Order"] . should_equal ignore_order=setup.is_database
                Table.new [orderColumn, dataCol, ["offset([Col], 1, Fill_With.Nothing)", ["B", "E", "C", Nothing, "D"]]]
        group_builder.specify "Negative n shifts the values down (n=2)" <|
            t2.offset ["Col"] -2 ..Nothing order_by=["Order"] . should_equal ignore_order=setup.is_database
                Table.new [orderColumn, dataCol, ["offset([Col], -2, Fill_With.Nothing)", [Nothing, "B", Nothing, "C", "A"]]]
        group_builder.specify "Positive n shifts the values up (n=2)" <|
            t2.offset ["Col"] 2 ..Nothing order_by=["Order"] . should_equal ignore_order=setup.is_database
                Table.new [orderColumn, dataCol, ["offset([Col], 2, Fill_With.Nothing)", ["C", Nothing, "D", Nothing, "E"]]]
        group_builder.specify "Zero n is a no-op" <|
            t2.offset ["Col"] 0 ..Nothing order_by=["Order"] . should_equal ignore_order=setup.is_database
                Table.new [orderColumn, dataCol, ["offset([Col], 0, Fill_With.Nothing)", ["A", "D", "B", "E", "C"]]]
        group_builder.specify "Large negative n values work" <|
            t2.offset ["Col"] -1024 ..Nothing order_by=["Order"] . should_equal ignore_order=setup.is_database
                Table.new [orderColumn, dataCol, ["offset([Col], -1024, Fill_With.Nothing)", [Nothing, Nothing, Nothing, Nothing, Nothing], Value_Type.Char]]
        group_builder.specify "Large positive n values work" <|
            t2.offset ["Col"] 1024 ..Nothing order_by=["Order"] . should_equal ignore_order=setup.is_database
                Table.new [orderColumn, dataCol, ["offset([Col], 1024, Fill_With.Nothing)", [Nothing, Nothing, Nothing, Nothing, Nothing], Value_Type.Char]]
    suite_builder.group prefix+"Table.Offset works with ordering - closest fill strategy" group_builder->
        orderColumn = ["Order", [1, 4, 2, 5, 3]]
        dataCol = ["Col", ["A", "D", "B", "E", "C"]]
        t2 = build_sorted_table [orderColumn, dataCol]
        group_builder.specify "Negative n shifts the values down" <|
            t2.offset ["Col"] -1 ..Closest_Value order_by=["Order"] . should_equal ignore_order=setup.is_database
                Table.new [orderColumn, dataCol, ["offset([Col], -1, Fill_With.Closest_Value)", ["A", "C", "A", "D", "B"]]]
        group_builder.specify "Positive n shifts the values up" <|
            t2.offset ["Col"] 1 ..Closest_Value order_by=["Order"] . should_equal ignore_order=setup.is_database
                Table.new [orderColumn, dataCol, ["offset([Col], 1, Fill_With.Closest_Value)", ["B", "E", "C", "E", "D"]]]
        group_builder.specify "Negative n shifts the values down (n=2)" <|
            t2.offset ["Col"] -2 ..Closest_Value order_by=["Order"] . should_equal ignore_order=setup.is_database
                Table.new [orderColumn, dataCol, ["offset([Col], -2, Fill_With.Closest_Value)", ["A", "B", "A", "C", "A"]]]
        group_builder.specify "Positive n shifts the values up (n=2)" <|
            t2.offset ["Col"] 2 ..Closest_Value order_by=["Order"] . should_equal ignore_order=setup.is_database
                Table.new [orderColumn, dataCol, ["offset([Col], 2, Fill_With.Closest_Value)", ["C", "E", "D", "E", "E"]]]
        group_builder.specify "Zero n is a no-op" <|
            t2.offset ["Col"] 0 ..Closest_Value order_by=["Order"] . should_equal ignore_order=setup.is_database
                Table.new [orderColumn, dataCol, ["offset([Col], 0, Fill_With.Closest_Value)", ["A", "D", "B", "E", "C"]]]
        group_builder.specify "Large negative n values work" <|
            t2.offset ["Col"] -1024 ..Closest_Value order_by=["Order"] . should_equal ignore_order=setup.is_database
                Table.new [orderColumn, dataCol, ["offset([Col], -1024, Fill_With.Closest_Value)", ["A", "A", "A", "A", "A"]]]
        group_builder.specify "Large positive n values work" <|
            t2.offset ["Col"] 1024 ..Closest_Value order_by=["Order"] . should_equal ignore_order=setup.is_database
                Table.new [orderColumn, dataCol, ["offset([Col], 1024, Fill_With.Closest_Value)", ["E", "E", "E", "E", "E"]]]
    if setup.is_database.not then suite_builder.group prefix+"Table.Offset works with ordering - wrap around fill strategy" group_builder->
        orderColumn = ["Order", [1, 4, 2, 5, 3]]
        dataCol = ["Col", ["A", "D", "B", "E", "C"]]
        t2 = build_sorted_table [orderColumn, dataCol]
        group_builder.specify "Negative n shifts the values down" <|
            t2.offset ["Col"] -1 ..Wrap_Around order_by=["Order"] . should_equal ignore_order=setup.is_database
                Table.new [orderColumn, dataCol, ["offset([Col], -1, Fill_With.Wrap_Around)", ["E", "C", "A", "D", "B"]]]
        group_builder.specify "Positive n shifts the values up" <|
            t2.offset ["Col"] 1 ..Wrap_Around order_by=["Order"] . should_equal ignore_order=setup.is_database
                Table.new [orderColumn, dataCol, ["offset([Col], 1, Fill_With.Wrap_Around)", ["B", "E", "C", "A", "D"]]]
        group_builder.specify "Negative n shifts the values down (n=2)" <|
            t2.offset ["Col"] -2 ..Wrap_Around order_by=["Order"] . should_equal ignore_order=setup.is_database
                Table.new [orderColumn, dataCol, ["offset([Col], -2, Fill_With.Wrap_Around)", ["D", "B", "E", "C", "A"]]]
        group_builder.specify "Positive n shifts the values up (n=2)" <|
            t2.offset ["Col"] 2 ..Wrap_Around order_by=["Order"] . should_equal ignore_order=setup.is_database
                Table.new [orderColumn, dataCol, ["offset([Col], 2, Fill_With.Wrap_Around)", ["C", "A", "D", "B", "E"]]]
        group_builder.specify "Zero n is a no-op" <|
            t2.offset ["Col"] 0 ..Wrap_Around order_by=["Order"] . should_equal ignore_order=setup.is_database
                Table.new [orderColumn, dataCol, ["offset([Col], 0, Fill_With.Wrap_Around)", ["A", "D", "B", "E", "C"]]]
        group_builder.specify "Large negative n values work" <|
            t2.offset ["Col"] -1024 ..Wrap_Around order_by=["Order"] . should_equal ignore_order=setup.is_database
                Table.new [orderColumn, dataCol, ["offset([Col], -1024, Fill_With.Wrap_Around)", ["B", "E", "C", "A", "D"]]]
        group_builder.specify "Large positive n values work" <|
            t2.offset ["Col"] 1024 ..Wrap_Around order_by=["Order"] . should_equal ignore_order=setup.is_database
                Table.new [orderColumn, dataCol, ["offset([Col], 1024, Fill_With.Wrap_Around)", ["E", "C", "A", "D", "B"]]]
    suite_builder.group prefix+"Table.Offset works with multiple columns" group_builder->
        col1 = ["Col1", ["A", "B", "C", "D"]]
        col2 = ["Col2", [1, 2, 3, 4]]
        t2 = build_sorted_table [col1, col2]
        group_builder.specify "Negative n shifts the values down" <|
            t2.offset ["Col1", "Col2"] -1 ..Nothing . should_equal ignore_order=setup.is_database
                Table.new [col1, col2, ["offset([Col1], -1, Fill_With.Nothing)", [Nothing, "A", "B", "C"]], ["offset([Col2], -1, Fill_With.Nothing)", [Nothing, 1, 2, 3]]]           
        group_builder.specify "Positive n shifts the values up" <|
            t2.offset ["Col1", "Col2"] 1 ..Nothing . should_equal ignore_order=setup.is_database
                Table.new [col1, col2, ["offset([Col1], 1, Fill_With.Nothing)", ["B", "C", "D", Nothing]], ["offset([Col2], 1, Fill_With.Nothing)", [2, 3, 4, Nothing]]]
        group_builder.specify "Negative n shifts the values down (n=2)" <|
            t2.offset ["Col1", "Col2"] -2 ..Nothing . should_equal ignore_order=setup.is_database
                Table.new [col1, col2, ["offset([Col1], -2, Fill_With.Nothing)", [Nothing, Nothing, "A", "B"]], ["offset([Col2], -2, Fill_With.Nothing)", [Nothing, Nothing, 1, 2]]]
        group_builder.specify "Positive n shifts the values up (n=2)" <|
            t2.offset ["Col1", "Col2"] 2 ..Nothing . should_equal ignore_order=setup.is_database
                Table.new [col1, col2, ["offset([Col1], 2, Fill_With.Nothing)", ["C", "D", Nothing, Nothing]], ["offset([Col2], 2, Fill_With.Nothing)", [3, 4, Nothing, Nothing]]]
        group_builder.specify "Zero n is a no-op" <|
            t2.offset ["Col1", "Col2"] 0 ..Nothing . should_equal ignore_order=setup.is_database
                Table.new [col1, col2, ["offset([Col1], 0, Fill_With.Nothing)", ["A", "B", "C", "D"]], ["offset([Col2], 0, Fill_With.Nothing)", [1, 2, 3, 4]]]
        group_builder.specify "Large negative n values work" <|
            t2.offset ["Col1", "Col2"] -1024 ..Nothing . should_equal ignore_order=setup.is_database
                Table.new [col1, col2, ["offset([Col1], -1024, Fill_With.Nothing)", [Nothing, Nothing, Nothing, Nothing], Value_Type.Char], ["offset([Col2], -1024, Fill_With.Nothing)", [Nothing, Nothing, Nothing, Nothing], Value_Type.Integer]]
        group_builder.specify "Large positive n values work" <|
            t2.offset ["Col1", "Col2"] 1024 ..Nothing . should_equal ignore_order=setup.is_database
                Table.new [col1, col2, ["offset([Col1], 1024, Fill_With.Nothing)", [Nothing, Nothing, Nothing, Nothing], Value_Type.Char], ["offset([Col2], 1024, Fill_With.Nothing)", [Nothing, Nothing, Nothing, Nothing], Value_Type.Integer]]
    suite_builder.group prefix+"Table.Offset works with multiple columns - updating in place" group_builder->
        col1 = ["Col1", ["A", "B", "C", "D"]]
        col2 = ["Col2", [1, 2, 3, 4]]
        t2 = build_sorted_table [col1, col2]
        group_builder.specify "Negative n shifts the values down" <|
            t2.offset ["Col1", "Col2"] -1 ..Nothing set_mode=..Update . should_equal ignore_order=setup.is_database
                Table.new [["Col1", [Nothing, "A", "B", "C"]], ["Col2", [Nothing, 1, 2, 3]]]
        group_builder.specify "Positive n shifts the values up" <|
            t2.offset ["Col1", "Col2"] 1 ..Nothing set_mode=..Update . should_equal ignore_order=setup.is_database
                Table.new [["Col1", ["B", "C", "D", Nothing]], ["Col2", [2, 3, 4, Nothing]]]
        group_builder.specify "Negative n shifts the values down (n=2)" <|
            t2.offset ["Col1", "Col2"] -2 ..Nothing set_mode=..Update . should_equal ignore_order=setup.is_database
                Table.new [["Col1", [Nothing, Nothing, "A", "B"]], ["Col2", [Nothing, Nothing, 1, 2]]]
        group_builder.specify "Positive n shifts the values up (n=2)" <|
            t2.offset ["Col1", "Col2"] 2 ..Nothing set_mode=..Update . should_equal ignore_order=setup.is_database
                Table.new [["Col1", ["C", "D", Nothing, Nothing]], ["Col2", [3, 4, Nothing, Nothing]]]
        group_builder.specify "Zero n is a no-op" <|
            t2.offset ["Col1", "Col2"] 0 ..Nothing set_mode=..Update . should_equal ignore_order=setup.is_database
                Table.new [["Col1", ["A", "B", "C", "D"]], ["Col2", [1, 2, 3, 4]]]
        group_builder.specify "Large negative n values work" <|
            t2.offset ["Col1", "Col2"] -1024 ..Nothing set_mode=..Update . should_equal ignore_order=setup.is_database
                Table.new [["Col1", [Nothing, Nothing, Nothing, Nothing], Value_Type.Char], ["Col2", [Nothing, Nothing, Nothing, Nothing], Value_Type.Integer]]
        group_builder.specify "Large positive n values work" <|
            t2.offset ["Col1", "Col2"] 1024 ..Nothing set_mode=..Update . should_equal ignore_order=setup.is_database
                Table.new [["Col1", [Nothing, Nothing, Nothing, Nothing], Value_Type.Char], ["Col2", [Nothing, Nothing, Nothing, Nothing], Value_Type.Integer]]
        group_builder.specify "Add_Or_Update equivalent to update" <|
            t2.offset ["Col1", "Col2"] -1 ..Nothing set_mode=..Add_Or_Update . should_equal ignore_order=setup.is_database
                Table.new [["Col1", [Nothing, "A", "B", "C"]], ["Col2", [Nothing, 1, 2, 3]]]
    suite_builder.group prefix+"Table.Offset handles bad inputs gracefully" group_builder->
        t2 = build_sorted_table [["Col1", ["A", "B", "C", "D"]], ["Col2", [1, 2, 3, 4]]]
        t3 = build_sorted_table [["Group", [1.1, 1.1, 1.1, 1.1]], ["Col2", [1, 2, 3, 4]]]
        group_builder.specify "Missing offset columns error" <|
            r = t2.offset
            r.should_fail_with Missing_Argument
            r.catch.argument_name . should_equal "columns"
        group_builder.specify "Empty offset columns is a no-op" <|
            t2.offset [] . should_equal t2
        group_builder.specify "Missing column is an error" <|
            t2.offset ["NotAColumn"] . should_fail_with (Missing_Input_Columns.Error ["NotAColumn"])
        group_builder.specify "Missing column is an error - grouping" <|
            t2.offset [] group_by=["NotAColumn"] . should_fail_with (Missing_Input_Columns.Error ["NotAColumn"])
        group_builder.specify "Missing column is an error - ordering" <|
            t2.offset [] order_by=["NotAColumn"] . should_fail_with (Missing_Input_Columns.Error ["NotAColumn"])
        group_builder.specify "Grouping by float warns" <|
            r = t3.offset ["Col2"] group_by=["Group"]
            Problems.expect_warning Floating_Point_Equality r
            r . at "offset([Col2], -1, Fill_With.Nothing)" .  to_vector . should_equal [Nothing, 1, 2, 3]
        group_builder.specify "Grouping by float errors if on_problems set" <|
            r = t3.offset ["Col2"] group_by=["Group"] on_problems=..Report_Error
            r.should_fail_with Floating_Point_Equality
        group_builder.specify "Grouping by float errors can be silenced using on_problems" <|
            r = t3.offset ["Col2"] group_by=["Group"] on_problems=..Ignore
            Warning.get_all r wrap_errors=True . should_equal []
            r . at "offset([Col2], -1, Fill_With.Nothing)" .  to_vector . should_equal [Nothing, 1, 2, 3]
        


