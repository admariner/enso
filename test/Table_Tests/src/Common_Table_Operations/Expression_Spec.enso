from Standard.Base import all
import Standard.Base.Errors.Common.Arithmetic_Error
import Standard.Base.Errors.Common.Floating_Point_Equality
import Standard.Base.Errors.Illegal_State.Illegal_State
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument

from Standard.Table import Table, Column, Sort_Column, Aggregate_Column, Value_Type, expr
from Standard.Table.Errors import all
import Standard.Table.Expression.Expression_Error

from Standard.Database.Errors import SQL_Error, Unsupported_Database_Type
import Standard.Database.Feature.Feature

from Standard.Test import all

from project.Util import all
from project.Common_Table_Operations.Util import run_default_backend, build_sorted_table

main filter=Nothing = run_default_backend (add_specs detailed=True) filter

type Lazy_Ref
    Value ~get

add_specs suite_builder detailed setup =
    if setup.is_feature_supported Feature.Column_Operations then (add_expression_specs suite_builder detailed setup)

add_expression_specs suite_builder detailed setup =
    prefix = setup.prefix+"(Expression_Spec) "
    table_builder = build_sorted_table setup
    column_a_description = ["A", [1, 2, 3, 4, 5]]
    column_odd_description = ["Bad] Name", [True, False, True, False, True]]
    test_table = Lazy_Ref.Value <|
        column_b = ["B", [1.0, 1.5, 2.5, 4, 6]]
        column_c = ["C", ["Hello", "World", "Hello World!", "", Nothing]]
        table_builder [column_a_description, column_b, column_c, column_odd_description]

    pending_datetime = if (setup.flagged ..Date_Time).not then "Date/Time operations are not supported by this backend."

    epsilon=0.0000000001

    check_results got_values expected =
        expected_vec = case expected of
            _ : Vector -> expected
            _ -> Vector.new test_table.get.row_count _->expected

        got_values . each_with_index i->v->
            e = expected_vec.at i
            match = case e of
                _ : Number -> case v of
                    _ : Number -> e.equals v epsilon
                    # If the backend returns Decimal for that case, we convert it to Float before comparing:
                    _ : Decimal -> e.equals v.to_float epsilon
                    _ -> Test.fail "Expected cell to be a number "+e.pretty+" but got a value of non-numeric type: "+v.pretty
                _ -> e == v
            if match.not then got_values.should_equal expected_vec

    tester expression value = Test.with_clue "{expr = {"+expression+"}}: " <|
        new_column = test_table.get.evaluate_expression expression
        new_column.name . should_equal expression
        check_results new_column.to_vector value

    specify_test label group_builder action pending=Nothing = case pending of
        Nothing ->
            case detailed of
                True ->
                    specify_tester expression value =
                        group_builder.specify (label + ": " + expression) <|
                            tester expression value
                    action specify_tester
                False ->
                    # We will batch the operation for better performance.
                    group_builder.specify label <|
                        batch = Vector.build batch_builder->
                            add_to_batch expression value =
                                new_column = test_table.get.evaluate_expression expression
                                new_column.name . should_equal expression
                                batch_builder.append [batch_builder.length, new_column, value]
                            action add_to_batch

                        expr_column_name ix = "expr_"+ix.to_text
                        batched_expression = batch.fold test_table.get acc-> entry->
                            ix = entry.at 0
                            new_column = entry.at 1
                            acc.set new_column as=(expr_column_name ix) set_mode=..Add
                        batched_expression_without_columns = batched_expression.select_columns "expr_.*".to_regex
                        materialized = batched_expression_without_columns.read
                        batch.each entry->
                            ix = entry.at 0
                            new_column = entry.at 1
                            expected = entry.at 2
                            Test.with_clue "{expr = {"+new_column.name+"}}: " <|
                                got_vector = materialized.at (expr_column_name ix) . to_vector
                                check_results got_vector expected

        _ -> group_builder.specify label Nothing pending

    suite_builder.group prefix+"Expression Integer literals" group_builder->
        specify_test "should be able to add an integer column" group_builder expression_test->
            expression_test "1" 1
            expression_test "-3" -3
            expression_test "1_000" 1000

    suite_builder.group prefix+"Expression Float literals" group_builder->
        specify_test "should be able to add an decimal column" group_builder expression_test->
            expression_test "1.23" 1.23
            expression_test "-3.1415" -3.1415
            expression_test "1_000.456" 1000.456

    suite_builder.group prefix+"Expression Boolean literals" group_builder->
        specify_test "should be able to add a boolean column" group_builder expression_test->
            expression_test "True" True
            expression_test "true" True
            expression_test "TRUE" True
            expression_test "tRuE" True
            expression_test "False" False
            expression_test "false" False
            expression_test "FALSE" False
            expression_test "FaLsE" False

    suite_builder.group prefix+"Expression Text literals" group_builder->
        specify_test "should be able to add a text column" group_builder expression_test->
            expression_test "'Hello World'" 'Hello World'
            expression_test "'Hello \'World\''" "Hello 'World'"
            expression_test '"Hello World"' 'Hello World'
            expression_test '"Hello ""World"""' 'Hello "World"'
            expression_test '"Hello \\""World"""' 'Hello \\"World"'
            expression_test "'Alpha\r\n\gBeta'" 'Alpha\r\n\\gBeta'

    suite_builder.group prefix+"Expression Text literals" group_builder->
        specify_test "should be able to get a Column" group_builder expression_test->
            expression_test "[A]" column_a_description.second
            expression_test "[Bad]] Name]" column_odd_description.second

        group_builder.specify "should sanitize names" <|
            t = table_builder [["X", ['\0', 'x', '']]]
            c = t.evaluate_expression '[X] == \'\0\'' . catch SQL_Error
            # We ignore the SQL error - some backends just do not support `\0` values. This is not the main point of this test.
            case c of
                _ : SQL_Error -> Nothing
                _ ->
                    c.name.should_equal "[X] == '\0'"
                    c.to_vector.should_equal [True, False, False]

    suite_builder.group prefix+"Expression Nothing literals" group_builder->
        if setup.is_database.not then specify_test "should be able to add an nothing column" group_builder expression_test->
            expression_test "null" Nothing
            expression_test "nUlL" Nothing
            expression_test "Nothing" Nothing
            expression_test "NOTHING" Nothing

        group_builder.specify "should allow to create a NULL column (or fail gracefully)" <|
            t = table_builder [["X", [1, 2, 3]]]
            c = t.evaluate_expression "null"

            should_be_supported = setup.is_database.not || c.is_error.not
            case should_be_supported of
                True ->
                    c.name . should_equal "null"
                    c.to_vector.should_equal [Nothing, Nothing, Nothing]
                    ## We do not specify the value type.
                       It usually will be `Mixed` in in-memory and
                       `Unsupported_Data_Type` in DB.
                    c.value_type.should_be_a Value_Type

                    c.is_nothing.to_vector.should_equal [True, True, True]

                # If not supported, verify that the error is sane.
                False -> c.should_fail_with Unsupported_Database_Type

        group_builder.specify "a null column should work with operations on any type" pending=(if setup.is_database then "Null columns not supported in DB") <|
            t = table_builder [["X", [1, 2, 3]]]
            c = t.evaluate_expression "null"
            nulls = [Nothing, Nothing, Nothing]
            c.not . to_vector . should_equal nulls

            (c + c) . to_vector . should_equal nulls
            (c - c) . to_vector . should_equal nulls
            (c * c) . to_vector . should_equal nulls
            (c / c) . to_vector . should_equal nulls
            (c ^ c) . to_vector . should_equal nulls
            (c % c) . to_vector . should_equal nulls
            (c.starts_with c) . to_vector . should_equal nulls
            (c.ends_with c) . to_vector . should_equal nulls
            (c.contains c) . to_vector . should_equal nulls

            t.evaluate_expression "not(Nothing)" . to_vector . should_equal nulls
            t.evaluate_expression "Nothing + Nothing" . to_vector . should_equal nulls
            t.evaluate_expression "[X] + Nothing" . to_vector . should_equal nulls
            t.evaluate_expression "Nothing + [X]" . to_vector . should_equal nulls

            t.evaluate_expression "Nothing * Nothing" . to_vector . should_equal nulls
            t.evaluate_expression "Nothing / Nothing" . to_vector . should_equal nulls
            t.evaluate_expression "Nothing ^ Nothing" . to_vector . should_equal nulls
            t.evaluate_expression "Nothing % Nothing" . to_vector . should_equal nulls

    suite_builder.group prefix+"Expression Date and Time literals" group_builder->
        specify_test "should be able to add a date or time column" group_builder pending=pending_datetime expression_test->
            expression_test "#2020-12-23#" (Date.new 2020 12 23)
            expression_test "#12:34#" (Time_Of_Day.new 12 34)
            expression_test "#12:34:56#" (Time_Of_Day.new 12 34 56)

        group_builder.specify "should be able to add a date-time column" pending=pending_datetime <|
            ## We cannot just test equality as the Database may change the timezone,
               so all we can do is check that the values are accepted and can be compared
               with other values in the database.
            t = table_builder [["X", [Date_Time.new 2020 12 23 12 34 56, Date_Time.new 2010 1 2]]]
            c = t.evaluate_expression "#2020-12-23 12:34:56# == [X]"
            c.to_vector . should_equal [True, False]

        specify_test "should be able to add a time column with sub-millisecond accuracy" group_builder pending=pending_datetime expression_test->
            expression_test "#12:34:56.789#" (Time_Of_Day.new 12 34 56 789)
            expression_test "#12:34:56.000123#" (Time_Of_Day.new 12 34 56 millisecond=0 microsecond=123 nanosecond=0)

        if setup.is_database.not then
            specify_test "should be able to add a date time column with timezone" group_builder expression_test->
                expression_test "#2020-12-23 12:34:56Z[UTC]#" (Date_Time.new 2020 12 23 12 34 56 zone=Time_Zone.utc)
                expression_test "#2020-12-23 12:34:56+02:30[UTC]#" (Date_Time.new 2020 12 23 10 04 56 zone=Time_Zone.utc)
                expression_test "#2020-12-23 12:34:56.157+01[UTC]#" (Date_Time.new 2020 12 23 11 34 56 157 zone=Time_Zone.utc)
                expression_test "#2020-12-23T12:34[Europe/Warsaw]#" (Date_Time.new 2020 12 23 12 34 zone=(Time_Zone.parse "Europe/Warsaw"))

        group_builder.specify "should correctly handle timezones" pending=pending_datetime <|
            ## We cannot just test equality as the Database may change the timezone,
               so all we can do is check that the values are accepted and can be compared
               with other values in the database.
            t = table_builder [["X", [Date_Time.new 2020 12 23 12 34 56 zone=Time_Zone.utc, Date_Time.new 2010 1 2 12 34 56 zone=(Time_Zone.parse "Europe/Warsaw")]]]
            c1 = t.evaluate_expression "#2020-12-23 12:34:56Z[UTC]# == [X]"
            c1.to_vector . should_equal [True, False]
            c2 = t.evaluate_expression "#2010-01-02 12:34:56[Europe/Warsaw]# == [X]"
            c2.to_vector . should_equal [False, True]

    suite_builder.group prefix+"Expression Arithmetic" group_builder->
        specify_test "should be able to do basic arithmetic" group_builder expression_test->
            expression_test "1+1" 2
            expression_test "23-15" 8
            expression_test "2.5*4.2" 10.5
            expression_test "1_000.456/2" 500.228
            expression_test "2^4" 16
            expression_test "11%3" 2

        specify_test "should be able to do basic arithmetic with order" group_builder expression_test->
            expression_test "1+1*2+2" 5
            expression_test "23-15/3+6" 24
            expression_test "52.92/4.2^2" 3
            expression_test "(1+1)*2+2" 6

        specify_test "should be able to do basic arithmetic with whitespace" group_builder expression_test->
            expression_test "1 + 1" 2
            expression_test "  23 -15  " 8
            expression_test "2.5*  4.2" 10.5
            expression_test "1_000.456/   2" 500.228
            expression_test " 2 ^ 4 " 16
            expression_test "  11   % 3    " 2
            expression_test "1+1 * 2" 3
            expression_test "1 + 1*2" 3

    suite_builder.group prefix+"Expression Column Arithmetic" group_builder->
        specify_test "should be able to perform arithmetic on columns" group_builder expression_test->
            expression_test "[A] + 2" [3, 4, 5, 6, 7]
            expression_test "[B] - 2" [-1, -0.5, 0.5, 2, 4]
            expression_test "[A] * 4" [4, 8, 12, 16, 20]
            expression_test "[B] / 2" [0.5, 0.75, 1.25, 2, 3]
            expression_test "[A] + [B]" [2, 3.5, 5.5, 8, 11]
            expression_test "[A] - [B]" [0, 0.5, 0.5, 0, -1]
            expression_test "[A] * [B]" [1, 3, 7.5, 16, 30]
            expression_test "[B] / [A]" [1, 0.75, 0.8333333333333334, 1, 1.2]
            expression_test "[A] ^ [B]" [1, 2.8284271247461903, 15.588457268119896, 256, 15625]
            expression_test "[A] % [B]" [0, 0.5, 0.5, 0, 5]
            expression_test "[A] + [B] + [A]" [3, 5.5, 8.5, 12, 16]
            expression_test "[A] - [B] - [A]" [-1, -1.5, -2.5, -4, -6]
            expression_test "[A] * [B] * [A]" [1, 6, 22.5, 64, 150]
            expression_test "[A] / [B] / [A]" [1.0, 0.6666666666666667, 0.39999999999999999, 0.25, 0.16666666666666667]
            expression_test "[A] ^ [B] * [A]" [1, 5.65685424949238, 46.7653718043597, 1024, 78125]
            expression_test "[A] % [B] % [A]" [0, 0.5, 0.5, 0, 0]

        specify_test "should be able to perform arithmetic on columns with order" group_builder expression_test->
            expression_test "([A] + [B]) * 3" [6, 10.5, 16.5, 24, 33]
            expression_test "[A] * (4 + [B])" [5, 11, 19.5, 32, 50]
            expression_test "[A] * [B] + [A]" [2, 5, 10.5, 20, 35]
            expression_test "[A] + [B] * [B]" [2, 4.25, 9.25, 20, 41]
            expression_test "([A] + [B]) / [A]" [2, 1.75, 1.83333333333333, 2, 2.2]
            expression_test "[A] / [B] + 2" [3, 3.33333333333333, 3.2, 3, 2.83333333333333]
            expression_test "([A] + [B]) % 4" [2, 3.5, 1.5, 0, 3]
            expression_test "[A] % [B] + 2" [2, 2.5, 2.5, 2, 7]
            expression_test "([A] - [B]) ^ [A]" [0, 0.25, 0.125, 0, -1]
            expression_test "[A] ^ ([B] - [A])" [1, 0.707106781186547, 0.577350269189626, 1, 5]

    suite_builder.group prefix+"Expression Comparison Operators" group_builder->
        specify_test "should be able to compare equality" group_builder expression_test->
            expression_test "2 = 1 + 1" True
            expression_test "2 == 1 + 1" True
            expression_test "[A] = 2" [False, True, False, False, False]
            expression_test "[A] == 2" [False, True, False, False, False]
            expression_test "3 != 1 + 1" True
            expression_test "3 <> 1 + 1" True
            expression_test "[A] != 2" [True, False, True, True, True]
            expression_test "[A] <> 2" [True, False, True, True, True]

        specify_test "should be able to compare ordering" group_builder expression_test->
            expression_test "1 > 2" False
            expression_test "1 < 2" True
            expression_test "[A] > 2" [False, False, True, True, True]
            expression_test "[A] >= 2" [False, True, True, True, True]
            expression_test "[A] < 2" [True, False, False, False, False]
            expression_test "[A] <= 2" [True, True, False, False, False]

        specify_test "should be able to use between" group_builder expression_test->
            expression_test "1 + 1 BETWEEN 1 AND 3" True
            expression_test "1 + 1 between 2 AND 3" True
            expression_test "1 + 1 bETWEEN 1 AND 2" True
            expression_test "[A] between 2 AND 3" [False, True, True, False, False]
            expression_test "1 + 1 NOT BETWEEN 1 AND 3" False
            expression_test "[A] not between 2 AND 3" [True, False, False, True, True]

        specify_test "should be able to use in" group_builder expression_test->
            expression_test "1 + 1 IN (2, 4, 6)" True
            expression_test "[A] IN (2, 4, 6)" [False, True, False, True, False]
            expression_test "1 + 1 NOT IN (2, 4, 6)" False
            expression_test "[A] NOT IN (2, 4, 6)" [True, False, True, False, True]
            expression_test "[A] IN (3)" [False, False, True, False, False]
            expression_test "[A] NOT IN (3)" [True, True, False, True, True]

        specify_test "should be able to check null" group_builder expression_test->
            expression_test "1 IS NULL" False
            expression_test "1 IS NoTHing" False
            expression_test "1 IS NOT NULL" True
            expression_test "[A] IS NULL" [False, False, False, False, False]
            expression_test "[C] IS NULL" [False, False, False, False, True]
            expression_test "[A] IS NOT NULL" [True, True, True, True, True]
            expression_test "[C] IS NOT NULL" [True, True, True, True, False]

            # This requires Null columns, so it's not generally tested on DB backends.
            if setup.is_database.not || (setup.prefix.contains "SQLite") then
                expression_test "Nothing IS NULL" True
                expression_test "Nothing IS NOT NULL" False

        specify_test "should be able to check empty" group_builder expression_test->
            expression_test "'Hello World' IS EMPTY" False
            expression_test "'' IS EMPTY" True
            expression_test "'Hello World' IS NOT EMPTY" True
            expression_test "'' IS NOT EMPTY" False

    suite_builder.group prefix+"Expression Text Operators" group_builder->
        specify_test "should be able to concatenate text" group_builder expression_test->
            expression_test "'Hello ' + 'World'" "Hello World"
            expression_test "[C] + ' World'" ["Hello World", "World World", "Hello World! World", " World", Nothing]
            expression_test "'Hello ' + [C]" ["Hello Hello", "Hello World", "Hello Hello World!", "Hello ", Nothing]
            expression_test "[C] + [C]" ["HelloHello", "WorldWorld", "Hello World!Hello World!", "", Nothing]

        specify_test "should be able to use like" group_builder expression_test->
            expression_test "'Hello World' LIKE 'Hello%'" True
            expression_test "'Hello' LIKE 'H_llo'" True
            expression_test "'Hello' LIKE 'H_l%'" True
            expression_test "'Hello' LIKE 'H___o'" True
            expression_test "'World' LIKE 'H___o'" False
            expression_test "'Hello World' NOT LIKE 'Hello%'" False
            expression_test "[C] LIKE 'Hello%'" [True, False, True, False, Nothing]
            expression_test "[C] NOT LIKE 'Hello%'" [False, True, False, True, Nothing]

    suite_builder.group prefix+"Expression Boolean Operators" group_builder->
        specify_test "should be able to AND booleans" group_builder expression_test->
            expression_test "True && TRUE" True
            expression_test "True AND False" False

            expression_test "True && Nothing" Nothing

            # This requires Null columns, so it's not generally tested on DB backends.
            if setup.is_database.not || (setup.prefix.contains "SQLite")  then
                expression_test "Nothing && False" False
                expression_test "Nothing && True" Nothing

            expression_test "True && [Bad]] Name]" [True, False, True, False, True]
            expression_test "False AND [Bad]] Name]" False

        specify_test "should be able to OR booleans" group_builder expression_test->
            expression_test "True || TRUE" True
            expression_test "True OR False" True
            expression_test "False OR False" False

            # This requires Null columns, so it's not generally tested on DB backends.
            if setup.is_database.not || (setup.prefix.contains "SQLite") then
                expression_test "Nothing || False" Nothing
                expression_test "Nothing || True" True

            expression_test "True OR [Bad]] Name]" True
            expression_test "False || [Bad]] Name]" [True, False, True, False, True]

        specify_test "should be able to NOT booleans" group_builder expression_test->
            expression_test "!TRUE" False
            expression_test "Not False" True
            expression_test "NOT [Bad]] Name]" [False, True, False, True, False]

        specify_test "should be able to use IF" group_builder expression_test->
            expression_test "IF True THEN 1 ELSE 0" 1
            expression_test "IF False THEN 'A' ELSE 'B' END" 'B'
            expression_test "IF [Bad]] Name] THEN [A] ELSE [B] ENDIF" [1, 1.5, 3, 4, 5]

    suite_builder.group prefix+"Function invocation" group_builder->
        specify_test "should be able to call a function with arguments" group_builder expression_test->
            expression_test "Not(True)" False
            expression_test "not(False)" True
            expression_test "iif(True, 1, 3)" 1
            expression_test "iif([Bad]] Name], 2, 3)" [2, 3, 2, 3, 2]

        specify_test "should be able to call a variable args function" group_builder expression_test->
            expression_test "min(10, 3, 8)" 3
            expression_test "max([A], [B], 3)" [3, 3, 3, 4, 6]

        specify_test "should be able to use functions with constants" group_builder expression_test->
            expression_test "truncate(3.3)" 3
            expression_test "CEIL(5.3)" 6
            expression_test "floor(5.3)" 5
            expression_test "rOuNd(5.5)" 6

        specify_test "should be able to use scalar functions" group_builder expression_test->
            expression_test "first([C])" "Hello"
            expression_test "at([C], 2)" "Hello World!"

        specify_test "should be able to pass Atom constructors to functions" group_builder expression_test->
            expression_test "cast([A], ..Char)" ["1", "2", "3", "4", "5"]
            expression_test "starts_WITH([C], 'HELLO', ..INSENSITIVE)" [True, False, True, False, Nothing]

    suite_builder.group prefix+"Expression Errors should be handled" group_builder->
        expect_error ctor expr =
            expr.should_fail_with Expression_Error
            expr.catch.should_be_a ctor

        group_builder.specify "should fail with Syntax_Error if badly formed" <|
            expect_error Expression_Error.Syntax_Error <| test_table.get.evaluate_expression "IIF [A] THEN 1 ELSE 2"
            expect_error Expression_Error.Syntax_Error <| test_table.get.evaluate_expression "A + B"
            expect_error Expression_Error.Syntax_Error <| test_table.get.evaluate_expression "#2022-31-21#"

        group_builder.specify "should fail with Unsupported_Operation if not sufficient arguments" <|
            expect_error Expression_Error.Unsupported_Operation <| test_table.get.evaluate_expression "unknown([C])"

        group_builder.specify "should fail with Argument_Mismatch if not sufficient arguments" <|
            expect_error Expression_Error.Argument_Mismatch <| test_table.get.evaluate_expression "starts_with([C])"

        group_builder.specify "should fail with Argument_Mismatch if too many arguments" <|
            expect_error Expression_Error.Argument_Mismatch <| test_table.get.evaluate_expression "is_empty([C], 'Hello')"

    suite_builder.group prefix+"Expression Warnings should be reported" group_builder->
        group_builder.specify "should report floating point equality" <|
            t1 = table_builder [["X", [1.5, 2.0, 0.0]]]

            r1 = t1.evaluate_expression "([X] == 2) || ([X] + 0.5 == 2)" on_problems=..Ignore
            Problems.assume_no_problems r1
            r1.to_vector . should_equal [True, True, False]

            r2 = t1.evaluate_expression "([X] == 2) || ([X] + 0.5 == 2)" on_problems=..Report_Warning
            Problems.get_attached_warnings r2 . each warn->
                (Error.unwrap warn).should_be_a Floating_Point_Equality
            r2.to_vector . should_equal [True, True, False]

            err3 = t1.evaluate_expression "([X] == 2) || ([X] + 0.5 == 2)" on_problems=..Report_Error
            err3.should_fail_with Floating_Point_Equality

            r4 = t1.evaluate_expression 'if ([X] != 2) && ([X] + 0.5 != 2) then "A" else "B"'
            r4.to_vector . should_equal ["B", "B", "A"]
            Problems.expect_warning Floating_Point_Equality r4

        db_pending = if setup.is_database then "Arithmetic error handling is currently not implemented for the Database backend."
        group_builder.specify "should report arithmetic errors" pending=db_pending <|
            t1 = table_builder [["X", [1.5, 2.0, 0.0]]]

            action1 = t1.evaluate_expression "3 / [X]" on_problems=_
            tester1 column =
                column.to_vector . should_equal [2.0, 1.5, Number.positive_infinity]
            problems1 = [Arithmetic_Error.Error "Division by zero (at rows [2])."]
            Problems.test_problem_handling action1 problems1 tester1

        group_builder.specify "already existing warnings should not be escalated to errors in error handling mode (1)" pending=db_pending <|
            t1 = table_builder [["X", [1.5, 2.0, 0.0]]]
            c1 = t1.evaluate_expression "3 / [X]" on_problems=..Report_Warning
            Problems.expect_warning Arithmetic_Error c1

            t2 = t1.set c1 as="Y"
            Problems.expect_warning Arithmetic_Error t2
            Problems.expect_warning Arithmetic_Error (t2.at "Y")

            c2 = t2.evaluate_expression "[Y] >= 42.0" on_problems=..Report_Error
            Problems.expect_warning Arithmetic_Error c2
            c2.to_vector . should_equal [False, False, True]

            c3 = t2.evaluate_expression "[Y] == 42.0" on_problems=..Report_Error
            c3.should_fail_with Floating_Point_Equality

            t3 = t2.set (expr 'if [Y] == 42.0 then "A" else "B"') as="Z" on_problems=..Report_Error
            t3.should_fail_with Floating_Point_Equality

            t4 = t2.set (expr 'if [Y] >= 42.0 then "A" else "B"') as="Z" on_problems=..Report_Error
            t4.at "Z" . to_vector . should_equal ["B", "B", "A"]
            # Should still keep the inherited warning from "Y".
            Problems.expect_warning Arithmetic_Error t4

        group_builder.specify "already existing warnings should not be escalated to errors in error handling mode (2)" <|
            t1 = table_builder [["X", [1.5, 2.0, 0.0]]]
            c1 = Warning.attach (Illegal_State.Error "FOO") (t1.evaluate_expression "[X] + 3.0")
            Problems.expect_warning Illegal_State c1

            t2 = t1.set c1 as="Y"
            Problems.expect_warning Illegal_State t2
            Problems.expect_warning Illegal_State (t2.at "Y")

            c2 = t2.evaluate_expression "[Y] >= 3.5" on_problems=..Report_Error
            Problems.expect_warning Illegal_State c2
            c2.to_vector . should_equal [True, True, False]

            c3 = t2.evaluate_expression "[Y] == 42.0" on_problems=..Report_Error
            c3.should_fail_with Floating_Point_Equality

            c4 = t2.evaluate_expression "[Y] == 3.0" on_problems=..Report_Warning
            c4.to_vector . should_equal [False, False, True]
            Problems.expect_warning Floating_Point_Equality c4
            # Should still keep the inherited warning from "Y".
            Problems.expect_warning Illegal_State c4

            t3 = t2.set (expr 'if [Y] == 42.0 then "A" else "B"') as="Z" on_problems=..Report_Error
            t3.should_fail_with Floating_Point_Equality

            t4 = t2.set (expr 'if [Y] >= 3.5 then "A" else "B"') as="Z" on_problems=..Report_Error
            t4.at "Z" . to_vector . should_equal ["A", "A", "B"]
            # Should still keep the inherited warning from "Y".
            Problems.expect_warning Illegal_State t4
