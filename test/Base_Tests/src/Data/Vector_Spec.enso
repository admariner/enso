from Standard.Base import all
from Standard.Base.Data.Array_Proxy import Array_Proxy
import Standard.Base.Errors.Empty_Error.Empty_Error
import Standard.Base.Data.Vector.Builder
import Standard.Base.Data.Vector.Map_Error
import Standard.Base.Data.Vector.No_Wrap
import Standard.Base.Errors.Common.Additional_Warnings
import Standard.Base.Errors.Common.Incomparable_Values
import Standard.Base.Errors.Common.Index_Out_Of_Bounds
import Standard.Base.Errors.Common.Missing_Argument
import Standard.Base.Errors.Common.Not_Found
import Standard.Base.Errors.Common.Type_Error
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument
import Standard.Base.Errors.Unimplemented.Unimplemented
import Standard.Base.Runtime.Debug
import Standard.Base.Runtime.Ref.Ref
import Standard.Base.Runtime.State
from Standard.Base.Panic import Wrapped_Dataflow_Error

from Standard.Test import all


polyglot java import java.util.ArrayList

type T
    Value a b

type T_Comparator
    compare t1 t2 =
        Ordering.compare t1.a t2.a
    hash t =
        Ordering.hash t.a

Comparable.from (that:T) = Comparable.new that T_Comparator

## Type that violates reflexivity
type My_Nan
    Value value

type My_Nan_Comparator
    compare _ _ = Nothing
    hash _ = 0

Comparable.from (that:My_Nan) = Comparable.new that My_Nan_Comparator

type My_Error
    Error a

type Foo
    Value vec

compare_tco a b = case a.vec.length == b.vec.length of
    False -> Ordering.compare a.vec.length b.vec.length
    True ->
        go ix = if ix > a.vec.length then Ordering.Equal else
            cmp = Ordering.compare (a.vec.at ix) (b.vec.at ix)
            case cmp of
                Ordering.Equal -> @Tail_Call go ix+1
                _ -> cmp
        go 0

foreign js generate_js_array = """
    return [1, 2, 3, 4, 5]

foreign js generate_nested_js_array = """
    return [[1, 2, 3], [4, 5]]

foreign python generate_py_array = """
    return [1, 2, 3, 4, None]

foreign python generate_nested_py_array = """
    return [[1, 2, 3], [4, 5]]

type_spec suite_builder name alter = suite_builder.group name group_builder->
    map_fun a = if a == 30 then Error.throw (My_Error.Error a) else a+1
    flat_map_fun a = if (a.at 0) == 30 then Error.throw (My_Error.Error a) else a+[100]
    map_with_index_fun i a =
        _ = i
        if a == 30 then Error.throw (My_Error.Error a) else a+1
    zip_fun a b = if a == 30 then Error.throw (My_Error.Error a) else a+b+1

    pending_js_missing = if Polyglot.is_language_installed "js" then Nothing else
        "Can't run JavaScript tests, language `js` is not installed."
    pending_python_missing = if Polyglot.is_language_installed "python" then Nothing else
        "Can't run Python tests, Python is not installed."

    group_builder.specify "text bytes" <|
        "Lore".utf_8 . should_equal [76, 111, 114, 101]

    group_builder.specify "should allow vector creation with a programmatic constructor" <|
        Vector.new 100 (ix -> ix + 1) . fold 0 (+) . should_equal 5050

        r = Ref.new 0
        next =
            r.put r.get+1
        const = Vector.new 4 _->next
        const.should_equal [0, 1, 2, 3]

    group_builder.specify "should allow vector creation with a constant constructor" <|
        Vector.fill 100 1 . fold (0) (+) . should_equal 100

        r = Ref.new 0
        next =
            r.put r.get+1
        const = Vector.fill 4 next
        const.should_equal [0, 0, 0, 0]

    group_builder.specify "should allow creation from arrays without mutability" pending=pending_js_missing <|
        built_from_js = Vector.from_polyglot_array generate_js_array
        built_from_js . should_equal (alter [1, 2, 3, 4, 5])

    group_builder.specify "should allow creation from arrays without mutability in Python" pending=pending_python_missing <|
        built_from_py = Vector.from_polyglot_array generate_py_array
        built_from_py . should_equal (alter [1, 2, 3, 4, Nothing])

    group_builder.specify "should allow creation from nested arrays from JavaScript" pending=pending_js_missing <|
        built_from_js = Vector.from_polyglot_array generate_nested_js_array
        built_from_js . should_equal (alter [[1, 2, 3], [4, 5]])

    group_builder.specify "should allow creation from nested arrays from Python" pending=pending_python_missing <|
        built_from_py = Vector.from_polyglot_array generate_nested_py_array
        built_from_py . should_equal (alter [[1, 2, 3], [4, 5]])

    group_builder.specify "should allow accessing elements" <|
        alter [1,2,3] . at 0 . should_equal 1
        alter [1,2,3] . at 2 . should_equal 3

    group_builder.specify "should allow to store dataflow errors and raise them on access" <|
        vec = [Error.throw (My_Error.Error "foo"), "bar"]
        vec.at 1 . should_equal "bar"
        vec.at 0 . should_fail_with My_Error
        vec.get 1 . should_equal "bar"
        vec.get 0 . should_fail_with My_Error

    group_builder.specify "should allow accessing elements with negative indices" <|
        alter [1,2,3] . at -1 . should_equal 3
        alter [1,2,3] . at -2 . should_equal 2
        alter [1,2,3] . at -3 . should_equal 1
        alter [1,2,3] . get -1 . should_equal 3
        alter [1,2,3] . get -2 . should_equal 2
        alter [1,2,3] . get -3 . should_equal 1

    group_builder.specify "should correctly handle out of bounds access" <|
        alter [1,2,3] . at -4 . should_fail_with Index_Out_Of_Bounds
        alter [1,2,3] . at 3 . should_fail_with Index_Out_Of_Bounds
        alter [1,2,3] . get -4 . should_equal Nothing
        alter [1,2,3] . get 3 . should_equal Nothing
        alter [1,2,3] . get -4 "???" . should_equal "???"
        alter [1,2,3] . get 3 "???" . should_equal "???"

    group_builder.specify "should have a well-defined length" <|
        alter [1,2,3] . length . should_equal 3

    group_builder.specify "should allow folding an operator over its elements" <|
        alter [1,2,3] . fold 0 (+) . should_equal 6
        alter [] . fold 123 (+) . should_equal 123

    group_builder.specify "should allow a running fold operator over its elements" <|
        alter [1,2,3] . running_fold 0 (+) . should_equal [1, 3, 6]
        alter [] . running_fold 123 (+) . should_equal []

    group_builder.specify "should allow to reduce elements if it is non-empty" <|
        alter [1,2,3] . reduce (+) . should_equal 6
        empty_vec = alter []
        empty_vec . reduce (+) . should_fail_with (Empty_Error.Error (Meta.type_of empty_vec))
        empty_vec . reduce (+) 0 . should_equal 0

    group_builder.specify "should check any" <|
        vec = alter [1, 2, 3, 4, 5]
        vec.any (ix -> ix > 3) . should_be_true
        vec.any (ix -> ix < 0) . should_be_false

        vec.any (..Greater 0) . should_be_true
        vec.any (..Less 3) . should_be_true
        vec.any (..Less 0) . should_be_false

        Test.expect_panic_with matcher=Type_Error (vec.any "invalid argument")

    group_builder.specify "should check all" <|
        vec = alter [1, 2, 3, 4, 5]
        vec.all (ix -> ix > 0) . should_be_true
        vec.all (ix -> ix < 5) . should_be_false

        vec.all (..Greater 0) . should_be_true
        vec.all (..Less 3) . should_be_false

        Test.expect_panic_with matcher=Type_Error (vec.all "invalid argument")

    group_builder.specify "should check contains" <|
        vec = alter [1, 2, 3, 4, 5]
        vec.contains 1 . should_be_true
        vec.contains 0 . should_be_false

    group_builder.specify "should check for emptiness" <|
        non_empty = alter [1]
        empty = alter []
        non_empty.is_empty . should_be_false
        empty.is_empty . should_be_true

    group_builder.specify "should check for non-emptiness" <|
        non_empty = alter [1]
        empty = alter []
        non_empty.not_empty . should_be_true
        empty.not_empty . should_be_false

    group_builder.specify "should filter elements by a predicate" <|
        vec = alter [1, 2, 3, 4, 5]
        vec.filter (x -> x > 3) . should_equal [4, 5]
        vec.filter (x -> x == 1) . should_equal [1]
        vec.filter (x -> x < 0) . should_equal []
        vec.filter (x -> if x == 2 then Error.throw <| My_Error.Error "foo" else True) . should_fail_with My_Error

    group_builder.specify "should filter numerical elements by Filter_Condition" <|
        vec = alter [1, 2, 3, 4, 5]
        vec.filter (..Greater 3) . should_equal [4, 5]
        vec.filter (..Less 3.5) . should_equal [1, 2, 3]
        vec.filter (..Equal 3) . should_equal [3]
        vec.filter (..Not_Equal 3) . should_equal [1, 2, 4, 5]
        vec.filter (..Equal_Or_Greater 3) . should_equal [3, 4, 5]
        vec.filter (..Equal_Or_Less (-1)) . should_equal []
        vec.filter (..Between 2 4) . should_equal [2, 3, 4]
        vec.filter (..Between 2.1 4.5) . should_equal [3, 4]
        vec.filter (..Between 2 4 Filter_Action.Remove) . should_equal [1, 5]
        vec.filter (..Is_In [7, 3, 2, 2, 2]) . should_equal [2, 3]
        vec.filter (..Is_In [7, 3, 2] Filter_Action.Remove) . should_equal [1, 4, 5]

        vec.filter ..Is_Nothing . should_equal []
        vec.filter ..Not_Nothing . should_equal [1, 2, 3, 4, 5]

        numvec = alter [1, 2.5, Number.nan, Number.positive_infinity, Number.negative_infinity, 0]
        # We need to use to_text because NaN!=NaN
        numvec.filter ..Is_Nan . map .to_text . should_equal ["NaN"]
        numvec.filter ..Not_Nan . should_equal [1, 2.5, Number.positive_infinity, Number.negative_infinity, 0]
        numvec.filter ..Is_Infinite . should_equal [Number.positive_infinity, Number.negative_infinity]
        numvec.filter ..Is_Finite . should_equal [1, 2.5, 0]

        ## Text based filters should fail with type error
        Test.expect_panic Type_Error (vec.filter (..Starts_With "a"))
        Test.expect_panic Type_Error (vec.filter (..Ends_With "a"))
        Test.expect_panic Type_Error (vec.filter (..Contains "a"))
        Test.expect_panic Type_Error (vec.filter (..Equal_Ignore_Case "a"))
        Test.expect_panic Type_Error (vec.filter (..Like "a%"))
        Test.expect_panic Type_Error (vec.filter ..Is_Empty)
        Test.expect_panic Type_Error (vec.filter ..Not_Empty)

        ## Boolean based filters should fail with type error
        Test.expect_panic Type_Error (vec.filter ..Is_True)
        Test.expect_panic Type_Error (vec.filter ..Is_False)

    group_builder.specify "should filter text elements by ." <|
        txtvec = alter ["aaa", "bbb", "abab", "cccc", "baaa", "ś"]
        txtvec.filter (..Contains "a") . should_equal ["aaa", "abab", "baaa"]
        txtvec.filter (..Contains "a" keep_or_remove=Filter_Action.Remove) . should_equal ["bbb", "cccc", "ś"]
        txtvec.filter (..Contains 'A' Case_Sensitivity.Sensitive) . should_equal []
        txtvec.filter (..Contains 'A' Case_Sensitivity.Insensitive) . should_equal ["aaa", "abab", "baaa"]
        txtvec.filter (..Contains 's\u0301') . should_equal ["ś"]
        txtvec.filter (..Contains 'S\u0301' Case_Sensitivity.Sensitive) . should_equal []
        txtvec.filter (..Contains 'S\u0301' Case_Sensitivity.Insensitive) . should_equal ["ś"]
        Test.expect_panic Type_Error (txtvec.filter (..Contains 42))
        txtvec.filter (..Starts_With "a") . should_equal ["aaa", "abab"]
        txtvec.filter (..Starts_With "a" keep_or_remove=Filter_Action.Remove) . should_equal ["bbb", "cccc", "baaa", "ś"]
        txtvec.filter (..Starts_With "A" Case_Sensitivity.Sensitive) . should_equal []
        txtvec.filter (..Starts_With "A" Case_Sensitivity.Insensitive) . should_equal ["aaa", "abab"]
        Test.expect_panic Type_Error (txtvec.filter (..Starts_With 42))
        txtvec.filter (..Ends_With "a") . should_equal ["aaa", "baaa"]
        txtvec.filter (..Ends_With "a" keep_or_remove=Filter_Action.Remove) . should_equal ["bbb", "abab", "cccc", "ś"]
        txtvec.filter (..Ends_With "A" Case_Sensitivity.Sensitive) . should_equal []
        txtvec.filter (..Ends_With "A" Case_Sensitivity.Insensitive) . should_equal ["aaa", "baaa"]
        Test.expect_panic Type_Error (txtvec.filter (..Ends_With 42))

        txtvec.filter (..Less than="a") . should_equal []
        txtvec.filter (..Greater than="b") . should_equal ["bbb", "cccc", "baaa", "ś"]
        txtvec.filter (..Between "b" "c") . should_equal ["bbb", "baaa"]
        txtvec.filter (..Is_In [1, 2]) . should_equal []
        txtvec.filter (..Is_In ["bbb", 's\u0301', "bbb", "FOOBAR"]) . should_equal ["bbb", "ś"]

        ## Boolean based filters should fail with type error
        Test.expect_panic Type_Error (txtvec.filter ..Is_True)
        Test.expect_panic Type_Error (txtvec.filter ..Is_False)

        alter ["", Nothing, " ", "a"] . filter (..Is_Empty) . should_equal ["", Nothing]
        alter ["", Nothing, " ", "a"] . filter (..Not_Empty) . should_equal [" ", "a"]
        alter ["abab", "aaabaaaa", "ba"] . filter (..Like "ba") . should_equal ["ba"]
        alter ["abab", "aaabaaaa"] . filter (..Like "_ba_") . should_equal ["abab"]
        alter ["abab", "aaabaaaa"] . filter (..Like "%ba__%") . should_equal ["aaabaaaa"]
        alter ["aaaa", "bbbbb", "[ab]aaaa"] . filter (..Like "[ab]%") . should_equal ["[ab]aaaa"]
        alter ["f.txt", "abc.*"] . filter (..Like "%.*") . should_equal ["abc.*"]

        txt2 = alter ['a\n\n\n', 'a\n', 'a\n\n\nb', 'a\nb', 'caa\nbb']
        txt2.filter (..Like 'a_') . should_equal ['a\n']
        txt2.filter (..Like 'a_' Filter_Action.Remove) . should_equal ['a\n\n\n', 'a\n\n\nb', 'a\nb', 'caa\nbb']
        txt2.filter (..Like 'a%') . should_equal ['a\n\n\n', 'a\n', 'a\n\n\nb', 'a\nb']
        txt2.filter (..Like 'a_b') . should_equal ['a\nb']
        txt2.filter (..Like '%\nb') . should_equal ['a\n\n\nb', 'a\nb']

        ## NUmber based filters should fail with type error
        Test.expect_panic Type_Error (txtvec.filter ..Is_Nan)
        Test.expect_panic Type_Error (txtvec.filter ..Not_Nan)
        Test.expect_panic Type_Error (txtvec.filter ..Is_Infinite)
        Test.expect_panic Type_Error (txtvec.filter ..Is_Finite)

    group_builder.specify "should filter unicode text elements by Filter_Condition" <|
        txt3 = alter ['śnieg', 's\u0301nieg', 'X', 'połać', 'połac\u0301']
        txt3.filter (..Starts_With 'ś') . should_equal ['śnieg', 's\u0301nieg']
        txt3.filter (..Contains 'ś') . should_equal ['śnieg', 's\u0301nieg']
        txt3.filter (..Ends_With 'ś') . should_equal []
        txt3.filter (..Ends_With 'ć') . should_equal ['połać', 'połac\u0301']
        ## There is a bug with Java Regex in Unicode normalized mode (CANON_EQ) with quoting.
           https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8032926
        # txt3.filter (..Like 'ś%') . should_equal ['śnieg', 's\u0301nieg']
        # This should be replaced with the disabled test above, once the related bug is fixed.
        txt3.filter (..Like 'ś%') . should_equal ['śnieg']

        txt4 = alter ['a', 'A', 'ś', 'Ś', 'ﬃ']
        txt4.filter (..Equal_Ignore_Case 'a') . should_equal ['a', 'A']
        txt4.filter (..Equal_Ignore_Case 's\u0301') . should_equal ['ś', 'Ś']
        txt4.filter (..Equal_Ignore_Case 'FFI') . should_equal ['ﬃ']

    group_builder.specify "should filter mixed elements by Filter_Condition" <|
        mixed = alter [1, Nothing, "b"]
        mixed.filter ..Is_Nothing . should_equal [Nothing]
        mixed.filter ..Not_Nothing . should_equal [1, "b"]
        Test.expect_panic Type_Error (mixed.filter ..Is_Empty)
        Test.expect_panic Type_Error (mixed.filter ..Not_Empty)

        (alter [2, "a"]).filter (..Greater 1) . should_fail_with Incomparable_Values

    group_builder.specify "should allow Nothing when filtering by Filter_Condition" <|
        (alter [1, 2, Nothing, 3]).filter (..Greater 2) . should_equal [3]
        (alter [1, 2, Nothing, 3]).filter (..Equal_Or_Less 2) . should_equal [1, 2]
        (alter ["a", 2, Nothing, 2]).filter (..Equal 2) . should_equal [2, 2]
        (alter ["a", 2, Nothing, "a", "a"]).filter (..Equal "a") . should_equal ["a", "a", "a"]

        (alter [1, Nothing, (1/0), (0.log 0)]).filter ..Is_Nan . map .to_text . should_equal ["NaN"]
        (alter [1, Nothing, (1/0), (0.log 0)]).filter ..Not_Nan . should_equal [1, Number.positive_infinity]
        (alter [1, Nothing, (1/0), (0.log 0)]).filter ..Is_Infinite . should_equal [Number.positive_infinity]
        (alter [1, Nothing, (1/0), (0.log 0)]).filter ..Is_Finite . should_equal [1]

        boolvec = alter [True, False, Nothing, True]
        boolvec.filter ..Is_True . should_equal [True, True]
        boolvec.filter ..Is_False . should_equal [False]

        txtvec = alter ["abab", "baaa", Nothing, "cccc", "BAAA"]
        txtvec.filter (..Equal_Ignore_Case "baaA") . should_equal ["baaa", "BAAA"]
        txtvec.filter (..Contains "a") . should_equal ["abab", "baaa"]
        txtvec.filter (..Starts_With "a") . should_equal ["abab"]
        txtvec.filter (..Ends_With "a") . should_equal ["baaa"]
        txtvec.filter (..Like "b%a") . should_equal ["baaa"]

        (alter ["a", 2, Nothing, 3]).filter (..Is_In [Nothing, 2]) . should_equal [2, Nothing]

    group_builder.specify "should have a friendly error when missing Filter_Condition arguments" <|
        v = alter [0, 1, 2]

        r1 = v.filter ..Less
        r1 . should_fail_with Missing_Argument
        r1.catch.to_display_text . should_contain "Provide a value for"

        v.filter (..Between 10) . should_fail_with Missing_Argument

    group_builder.specify "should filter elements with indices" <|
        (alter [0, 10, 2, 2] . filter_with_index (==)) . should_equal [0, 2]
        (alter [1, 2, 3, 4] . filter_with_index ix-> _-> ix < 2) . should_equal [1, 2]
        (alter [1, 2, 3, 4] . filter_with_index ix-> _-> if ix == 1 then Error.throw <| My_Error.Error "foo" else True) . should_fail_with My_Error

    group_builder.specify "should partition elements" <|
        vec = alter [1, 2, 3, 4, 5, Nothing]
        vec.partition (x -> x.is_nothing.not && x%2==0) . should_equal <| Pair.new [2, 4] [1, 3, 5, Nothing]
        (vec . partition x-> if x == 1 then Error.throw <| My_Error.Error "foo" else True) . should_fail_with My_Error

        vec.partition (..Between 2 4) . should_equal <| Pair.new [2, 3, 4] [1, 5, Nothing]
        vec.partition (..Between 2 4 Filter_Action.Remove) . should_equal <| Pair.new [1, 5, Nothing] [2, 3, 4]

        Test.expect_panic_with matcher=Type_Error (vec.partition "invalid arg")

    group_builder.specify "should partition elements with indices" <|
        alter ["a", "b", "c", "d"] . partition_with_index (ix -> _ -> ix % 2 == 0) == (Pair.new ["a", "c"] ["b", "d"])
        alter ["a", "b", "c", "d"] . partition_with_index (ix -> _ -> if ix % 2 == 0 then Error.throw <| My_Error.Error "foo" else True) . should_fail_with My_Error

    group_builder.specify "should allow to join a vector of text elements to form a single text" <|
        alter ["a", "b", "c"] . join . should_equal "abc"
        alter ["a", "b", "c"] . join ";" "{" "}" . should_equal "{a;b;c}"

    group_builder.specify "should allow mapping an operation, returning a new vector" <|
        vec = alter [1, 2, 3, 4]
        mapped = vec.map x-> x * x
        vec.to_text.should_equal "[1, 2, 3, 4]"
        mapped.to_text.should_equal "[1, 4, 9, 16]"

    group_builder.specify "should allow map on_problems=No_Wrap, returning a new vector" <|
        vec = alter [1, 2, 3, 4]
        mapped = vec.map on_problems=No_Wrap.Value x-> x * x
        vec.to_text.should_equal "[1, 2, 3, 4]"
        mapped.to_text.should_equal "[1, 4, 9, 16]"

    group_builder.specify "should allow mapping an operation with index" <|
        vec = alter [1, 2, 3, 4]
        mapped = vec.map_with_index i-> x-> x * x * i
        vec.to_text.should_equal "[1, 2, 3, 4]"
        mapped.to_text.should_equal "[0, 4, 18, 48]"

    group_builder.specify "should allow flat_mapping an operation, returning a new vector" <|
        vec = alter [1, 2, 0, 3]
        mapped = vec.flat_map n-> Vector.fill n n
        mapped.should_equal [1, 2, 2, 3, 3, 3]

    group_builder.specify "should allow to flatten a nested vector" <|
        alter [[1, 2, 3], [4, 10], [], [0], [0]] . flatten . should_equal [1, 2, 3, 4, 10, 0, 0]
        alter [] . flatten . should_equal []
        alter [[]] . flatten . should_equal []
        alter [[], []] . flatten . should_equal []
        alter [[1]] . flatten . should_equal [1]
        alter [[[1], [2, 3]], [[4]]] . flatten . should_equal [[1], [2, 3], [4]]
        alter [["a", 2], [], [[[3]]], [T.Value 1 2, 44]] . flatten . should_equal ["a", 2, [[3]], T.Value 1 2, 44]
        (alter ["polyglot", " ", "array"] . map .utf_8).flatten . should_equal "polyglot array".utf_8

    group_builder.specify "should allow applying a function to each element" <|
        vec = alter [1, 2, 3, 4]
        result = Vector.build builder->
            vec.each builder.append
        result . should_equal vec

    group_builder.specify "dataflow errors in .each should become panics" <|
        do_write x =
            Error.throw "Failed to write "+x.to_text
        vec = alter [1, 2, 3, 4]
        Test.expect_panic_with (vec.each do_write) Text

    group_builder.specify "should accept changed elements" <|
        vec = alter <| Vector.build builder->
            builder.append 1
            builder.append 1.1
            builder.append Nothing

        vec.length . should_equal 3
        vec.at 0 . should_equal 1
        vec.at 1 . should_equal 1.1
        vec.at 2 . should_equal Nothing

    group_builder.specify "should accept Nothing" <|
        vec = alter <| Vector.build builder->
            builder.append Nothing

        vec.length . should_equal 1
        vec.at 0 . should_equal Nothing

    group_builder.specify "should allow reversing" <|
        alter [1, 2, 3] . reverse . should_equal [3, 2, 1]

    group_builder.specify "should have a well-defined text conversion" <|
        alter [] . to_text . should_equal "[]"
        alter [1,2,3] . to_text . should_equal "[1, 2, 3]"
        alter [Nothing] . to_text . should_equal "[Nothing]"
        alter ['a'] . to_text . should_equal "[a]"

    group_builder.specify "should allow to generate a short text representation for display" <|
        alter [] . short_display_text max_entries=3 . should_equal "[]"
        alter [1] . short_display_text max_entries=3 . should_equal "[1]"
        alter [1, 2] . short_display_text max_entries=3 . should_equal "[1, 2]"
        alter [1, 2, 3] . short_display_text max_entries=3 . should_equal "[1, 2, 3]"
        alter [1, 2, 3, 4] . short_display_text max_entries=3 . should_equal "[1, 2, 3 and 1 more element]"
        alter [1, 2, 3, 4, 5, 6] . short_display_text max_entries=3 . should_equal "[1, 2, 3 and 3 more elements]"
        alter (0.up_to 100).to_vector . short_display_text max_entries=2 . should_equal "[0, 1 and 98 more elements]"

        alter [1, 2] . to_display_text . should_equal "[1, 2]"

        alter [] . short_display_text max_entries=0 . should_fail_with Illegal_Argument

    group_builder.specify "should define equality" <|
        (alter [1,2,3])==[1,2] . should_be_false
        (alter [1,2,3])==[1,2,3] . should_be_true
        (alter [1,2,3])==[3,4,5] . should_be_false

    group_builder.specify "should define concatenation" <|
        concat = (alter [1, 2, 3]) + (alter [4, 5, 6])
        concat.should_equal [1, 2, 3, 4, 5, 6]
        Test.expect_panic_with matcher=Type_Error ((alter [1, 2, 3])+1)

    group_builder.specify "should allow finding a value" <|
        input = alter [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        input.find (x -> x == 5) . should_equal 5
        input.find (x -> x%3 == 2) . should_equal 2
        input.find (x -> x%3 == 3) . should_fail_with Not_Found
        input.find (x -> x%3 == 2) start=3 . should_equal 5
        input.find (x -> x%3 == 2) start=-3 . should_equal 8
        input.find (x -> x%3 == 2) start=10 . should_fail_with Not_Found
        input.find (x -> x%3 == 2) start=11 . should_fail_with Index_Out_Of_Bounds
        input.find (x -> x%3 == 2) start=11 . catch . should_equal (Index_Out_Of_Bounds.Error 11 11)
        input.find (x -> x%3 == 2) start=100 . should_fail_with Index_Out_Of_Bounds
        input.find (x -> x%3 == 2) start=-100 . should_fail_with Index_Out_Of_Bounds
        input.find (x -> x%3 == 3) if_missing=Nothing . should_equal Nothing

        input.find (..Greater 5) . should_equal 6
        Test.expect_panic_with matcher=Type_Error (input.find "invalid arg")

        alter ["b", "A", "c"] . find (..Equal_Ignore_Case "a") . should_equal "A"

    group_builder.specify "should allow finding the index of a value" <|
        input = alter [1, 2, 3, 4, 1, 2, 3, 1, 2, 1]
        input.index_of 4 . should_equal 3
        input.index_of (>3) . should_equal 3
        input.index_of 5 . should_equal Nothing
        [].index_of 5 . should_equal Nothing
        input.index_of 2 start=3 . should_equal 5
        input.index_of 2 start=-2 . should_equal 8
        input.index_of 2 start=10 . should_equal Nothing
        input.index_of 2 start=11 . should_fail_with Index_Out_Of_Bounds
        input.index_of 2 start=11 . catch . should_equal (Index_Out_Of_Bounds.Error 11 11)
        input.index_of 2 start=-11 . should_fail_with Index_Out_Of_Bounds

        input.index_of (..Equal_Or_Greater 2) . should_equal 1
        input.index_of "text" . should_equal Nothing

    group_builder.specify "should allow finding the last index of a value" <|
        input = alter [1, 2, 3, 4, 1, 2, 3, 1, 2, 1]
        input.last_index_of 2 . should_equal 8
        input.last_index_of 5 . should_equal Nothing
        [].last_index_of 5 . should_equal Nothing
        input.last_index_of 2 start=4 . should_equal 1
        input.last_index_of 2 start=-1 . should_equal 8
        input.last_index_of 2 start=10 . should_fail_with Index_Out_Of_Bounds
        input.last_index_of 2 start=10 . catch . should_equal (Index_Out_Of_Bounds.Error 10 10)
        input.last_index_of 2 start=-11 . should_fail_with Index_Out_Of_Bounds

        input.last_index_of (..Equal_Or_Greater 2) . should_equal input.length-2
        input.last_index_of "text" . should_equal Nothing

    group_builder.specify "should be convertible to a list" <|
        alter [] . to_list . should_equal List.Nil
        alter ["A"] . to_list . should_equal (List.Cons "A" List.Nil)
        alter [1, 2, "B", 3] . to_list . should_equal (List.Cons 1 (List.Cons 2 (List.Cons "B" (List.Cons 3 List.Nil))))

    group_builder.specify "Vector slice should return a Vector" <|
        vec = alter [1, 2, 3, 4, 5, 6]
        vec.slice 0 3 . should_equal [1, 2, 3]
        vec.slice 1 3 . should_equal [2, 3]
        vec.slice 1 1 . should_equal []
        vec.slice 0 100 . should_equal [1, 2, 3, 4, 5, 6]

        (vec.slice 1 1) . to Meta.Type . qualified_name . should_equal (Meta.meta Vector . qualified_name)
        (vec.slice 1 1) . to Meta.Type . name . should_equal "Vector"

    group_builder.specify "should define take and drop family of operations" <|
        vec = alter [1, 2, 3, 4, 5, 6]
        first_four = alter [1, 2, 3, 4]
        last_four = alter [3, 4, 5, 6]

        vec.take . should_equal [1]
        vec.drop . should_equal [2, 3, 4, 5, 6]

        vec.take (2.up_to 4) . should_equal [3, 4]
        vec.take (0.up_to 0) . should_equal []
        vec.take (100.up_to 100) . should_fail_with Index_Out_Of_Bounds
        vec.take (100.up_to 100) . catch . should_equal (Index_Out_Of_Bounds.Error 100 6)
        vec.take (0.up_to 100) . should_equal vec
        [].take (0.up_to 0) . should_fail_with Index_Out_Of_Bounds
        [].take (0.up_to 0) . catch . should_equal (Index_Out_Of_Bounds.Error 0 0)
        vec.take (100.up_to 99) . should_fail_with Index_Out_Of_Bounds

        vec.drop (2.up_to 4) . should_equal [1, 2, 5, 6]
        vec.drop (0.up_to 0) . should_equal vec
        vec.drop (100.up_to 100) . should_fail_with Index_Out_Of_Bounds
        vec.drop (100.up_to 100) . catch . should_equal (Index_Out_Of_Bounds.Error 100 6)
        vec.drop (0.up_to 100) . should_equal []
        [].drop (0.up_to 0) . should_fail_with Index_Out_Of_Bounds
        [].drop (0.up_to 0) . catch . should_equal (Index_Out_Of_Bounds.Error 0 0)
        vec.drop (100.up_to 99) . should_fail_with Index_Out_Of_Bounds

        vec.take (..First 4) . should_equal first_four
        vec.take (..First 0) . should_equal []
        vec.take (..First -1) . should_equal []
        vec.take (..First 100) . should_equal vec

        vec.drop (..First 2) . should_equal last_four
        vec.drop (..First 0) . should_equal vec
        vec.drop (..First -1) . should_equal vec
        vec.drop (..First 100) . should_equal []

        vec.take 4 . should_equal first_four
        vec.take 0 . should_equal []
        vec.take -1 . should_equal []
        vec.take 100 . should_equal vec

        vec.drop 2 . should_equal last_four
        vec.drop 0 . should_equal vec
        vec.drop -1 . should_equal vec
        vec.drop 100 . should_equal []

        vec.take (..Last 4) . should_equal last_four
        vec.take (..Last 0) . should_equal []
        vec.take (..Last -1) . should_equal []
        vec.take (..Last 100) . should_equal vec

        vec.drop (..Last 2) . should_equal first_four
        vec.drop (..Last 0) . should_equal vec
        vec.drop (..Last -1) . should_equal vec
        vec.drop (..Last 100) . should_equal []

        vec.take (..Every 1) . should_equal vec
        vec.take (..Every 3) . should_equal [1, 4]
        vec.take (..Every 3 first=1) . should_equal [2, 5]
        vec.take (..Every 2 first=1) . should_equal [2, 4, 6]
        vec.take (..Every 2 first=100) . should_equal []
        vec.take (..Every 200) . should_equal [1]
        [].take (..Every 2) . should_equal []
        vec.take (..Every 0) . should_fail_with Illegal_Argument
        [].take (..Every 0) . should_fail_with Illegal_Argument

        vec.drop (..Every 1) . should_equal []
        vec.drop (..Every 3) . should_equal [2, 3, 5, 6]
        vec.drop (..Every 3 first=1) . should_equal [1, 3, 4, 6]
        vec.drop (..Every 2 first=1) . should_equal [1, 3, 5]
        vec.drop (..Every 2 first=100) . should_equal vec
        vec.drop (..Every 200) . should_equal [2, 3, 4, 5, 6]
        [].drop (..Every 2) . should_equal []
        vec.drop (..Every 0) . should_fail_with Illegal_Argument
        [].drop (..Every 0) . should_fail_with Illegal_Argument

        vec.take (..By_Index 0) . should_equal [1]
        [].take (..By_Index 0) . should_fail_with Index_Out_Of_Bounds
        vec.take (..By_Index []) . should_equal []
        vec.take (..By_Index [-1, -1]) . should_equal [6, 6]
        vec.take (..By_Index [0, 0, 3.up_to 100]) . should_equal [1, 1, 4, 5, 6]
        vec.take (0.up_to 100 . with_step 2) . should_equal [1, 3, 5]
        vec.take (..By_Index [0.up_to 100 . with_step 2, 1.up_to 6 . with_step 2]) . should_equal [1, 3, 5, 2, 4, 6]
        vec.take (..By_Index [1.up_to 3, 2.up_to 5]) . should_equal [2, 3, 3, 4, 5]
        vec.take (..By_Index [2.up_to 5, 1.up_to 3]) . should_equal [3, 4, 5, 2, 3]
        vec.take (..By_Index [0, 1, 100.up_to 200]) . should_fail_with Index_Out_Of_Bounds
        vec.take (..By_Index 100) . should_fail_with Index_Out_Of_Bounds

        vec.drop (..By_Index 0) . should_equal [2, 3, 4, 5, 6]
        vec.drop (..By_Index []) . should_equal vec
        vec.drop (..By_Index [-1, -1]) . should_equal [1, 2, 3, 4, 5]
        vec.drop (..By_Index [0, 0, 3.up_to 100]) . should_equal [2, 3]
        vec.drop (0.up_to 100 . with_step 2) . should_equal [2, 4, 6]
        vec.drop (..By_Index [0.up_to 100 . with_step 2, 1.up_to 6 . with_step 2]) . should_equal []
        vec.drop (..By_Index [1.up_to 3, 2.up_to 5]) . should_equal [1, 6]
        vec.drop (..By_Index [2.up_to 5, 1.up_to 3]) . should_equal [1, 6]
        vec.drop (..By_Index [0, 1, 100.up_to 200]) . should_fail_with Index_Out_Of_Bounds
        vec.drop (..By_Index 100) . should_fail_with Index_Out_Of_Bounds

        [1, 3, 5, 6, 8, 9, 10, 11, 13].take (..While (x-> x%2 == 1)) . should_equal [1, 3, 5]
        alter [1, 2, 3] . take (..While (_ > 10)) . should_equal []
        alter [1, 2, 3] . take (..While (_ < 10)) . should_equal [1, 2, 3]

        [1, 3, 5, 6, 8, 9, 10, 11, 13].drop (..While (x-> x%2 == 1)) . should_equal [6, 8, 9, 10, 11, 13]
        alter [1, 2, 3] . drop (..While (_ > 10)) . should_equal [1, 2, 3]
        alter [1, 2, 3] . drop (..While (_ < 10)) . should_equal []

        vec.take (..Sample 0) . should_equal []
        alter [] . take (..Sample 0) . should_equal []
        alter [] . take (..Sample 1) . should_fail_with Illegal_Argument
        alter ["a"] . take (..Sample 1) . should_equal ["a"]
        alter ["a", "a", "a"] . take (..Sample 1) . should_equal ["a"]
        alter ["a", "a", "a"] . take (..Sample 3) . should_equal ["a", "a", "a"]
        alter ["a", "a", "a"] . take (..Sample 100) . should_fail_with Illegal_Argument

        vec.drop (..Sample 0) . should_equal vec
        alter [] . drop (..Sample 0) . should_equal []
        alter [] . drop (..Sample 1) . should_equal []
        alter ["a"] . drop (..Sample 1) . should_equal []
        alter ["a", "a", "a"] . drop (..Sample 1) . should_equal ["a", "a"]
        alter ["a", "a", "a"] . drop (..Sample 100) . should_equal []

    suite_builder.group "take/drop Sample non-determinism" group_builder->
        v = 0.up_to 60 . to_vector

        group_builder.specify "sampling should be deterministic when a seed is supplied" <|
            v.take (..Sample 5 seed=4200000) . should_equal (v.take (..Sample 5 seed=4200000))

        group_builder.specify "sampling should be non-deterministic when a seed is not supplied" <|
            v.take (..Sample 5) . should_not_equal (v.take (..Sample 5))

    group_builder.specify "take/drop should gracefully handle missing constructor arguments" <|
        Test.expect_panic Type_Error <| [].take "FOO"
        Test.expect_panic Type_Error <| [].drop "FOO"

        r1 = [].take (..While)
        r1.should_fail_with Missing_Argument
        r1.catch.to_display_text . should_contain "Provide a value for the argument `predicate`."

        r2 = [].take (..By_Index)
        r2.should_fail_with Missing_Argument
        r2.catch.to_display_text . should_contain "Provide a value for the argument `indexes`."

    group_builder.specify "should allow getting the last element of the vector" <|
        non_empty_vec = alter [1, 2, 3, 4, 5]
        singleton_vec = alter [1]
        empty_vec = alter []
        non_empty_vec.last . should_equal 5
        singleton_vec.last . should_equal 1
        empty_vec.last . should_fail_with Index_Out_Of_Bounds

    group_builder.specify "should allow getting the first element" <|
        non_empty_vec = alter [1, 2, 3, 4, 5]
        singleton_vec = alter [1]
        empty_vec = alter []
        non_empty_vec.first . should_equal 1
        singleton_vec.first . should_equal 1
        empty_vec.first . should_fail_with Index_Out_Of_Bounds

    group_builder.specify "should allow getting the second element" <|
        non_empty_vec = alter [1, 2, 3, 4, 5]
        singleton_vec = alter [1]
        empty_vec = alter []
        non_empty_vec.second . should_equal 2
        singleton_vec.second . should_fail_with Index_Out_Of_Bounds
        empty_vec.second . should_fail_with Index_Out_Of_Bounds

    group_builder.specify "should be able to be sorted" <|
        empty_vec = alter []
        short_vec = alter [2, 4, 38, -1, -1000, 3671, -32]
        short_expected = alter [-1000, -32, -1, 2, 4, 38, 3671]
        empty_vec.sort . should_equal []
        short_vec.sort . should_equal short_expected

        alter ["aa", "bb", "ba"] . sort . should_equal ["aa", "ba", "bb"]
        alter [Date.new 2000, Date.new 1999 10 11, Date.new 1990] . sort . should_equal [Date.new 1990, Date.new 1999 10 11, Date.new 2000]
        alter [Time_Of_Day.new 12, Time_Of_Day.new 10 30] . sort . should_equal [Time_Of_Day.new 10 30, Time_Of_Day.new 12]
        alter [Date_Time.new 2000 12 30 12 30, Date_Time.new 2000 12 30 12 00] . sort . should_equal [Date_Time.new 2000 12 30 12 00, Date_Time.new 2000 12 30 12 30]

        alter ["aa", 2] . sort . should_equal [2, "aa"]
        alter [2, Date.new 1999] . sort . should_equal [2, Date.new 1999]

    group_builder.specify "should leave the original vector unchanged" <|
        non_empty_vec = alter [2, 4, 2, 3, 2, 3]
        sorted = non_empty_vec.sort
        non_empty_vec . should_equal [2, 4, 2, 3, 2, 3]
        sorted . should_equal [2, 2, 2, 3, 3, 4]

    group_builder.specify "should have a stable sort" <|
        small_vec = alter [T.Value 1 8, T.Value 1 3, T.Value -20 0, T.Value -1 1, T.Value -1 10, T.Value 4 0]
        small_expected = [T.Value -20 0, T.Value -1 1, T.Value -1 10, T.Value 1 8, T.Value 1 3, T.Value 4 0]
        small_vec.sort . should_equal small_expected

    group_builder.specify "should fail the sort if `Report_Error` problem_behavior specified" <|
        alter [T.Value 1 8, Nothing] . sort on_problems=..Report_Error . should_fail_with Incomparable_Values
        alter [Nothing, Number.nan] . sort on_problems=..Report_Error . should_fail_with Incomparable_Values

    group_builder.specify "should be able to use a custom element projection" <|
        small_vec = alter [T.Value 1 8, T.Value 1 3, T.Value -20 0, T.Value -1 1, T.Value -1 10, T.Value 4 0]
        small_expected = [T.Value -20 0, T.Value 4 0, T.Value -1 1, T.Value 1 3, T.Value 1 8, T.Value -1 10]
        small_vec.sort (on = _.b) . should_equal small_expected
        small_vec.sort (on = .b) . should_equal small_expected

    group_builder.specify "should be able to use a custom compare function" <|
        small_vec = alter [2, 7, -3, 383, -392, 28, -90]
        small_expected = [383, 28, 7, 2, -3, -90, -392]
        small_vec.sort (by = l -> r -> Ordering.compare r l) . should_equal small_expected

    group_builder.specify "should allow tail-recursive comparators in sort" <|
         v = alter [Foo.Value [4,2,2], Foo.Value [1,2,3], Foo.Value [1,2,4]]
         r = alter [Foo.Value [1,2,3], Foo.Value [1,2,4], Foo.Value [4,2,2]]
         v.sort by=compare_tco . should_equal r

    group_builder.specify "should be able to use a custom compare function and projection" <|
        small_vec = alter [T.Value 1 8, T.Value 1 3, T.Value -20 0, T.Value -1 1, T.Value -1 10, T.Value 4 0]
        small_expected = alter [T.Value -1 10, T.Value 1 8, T.Value 1 3, T.Value -1 1, T.Value -20 0, T.Value 4 0]
        small_vec.sort (on = _.b) (by = l -> r -> Ordering.compare r l) . should_equal small_expected

    group_builder.specify "should be able to sort in descending order" <|
        small_vec = alter [2, 7, -3, 383, -392, 28, -90]
        small_expected = alter [383, 28, 7, 2, -3, -90, -392]
        small_vec.sort Sort_Direction.Descending . should_equal small_expected

    group_builder.specify "should be stable in descending order" <|
        small_vec = alter [T.Value 1 8, T.Value 1 3, T.Value -20 0, T.Value -1 1, T.Value -1 10, T.Value 4 0]
        small_expected = alter [T.Value 4 0, T.Value 1 3, T.Value 1 8, T.Value -1 10, T.Value -1 1, T.Value -20 0]
        sorted_vec = small_vec.sort Sort_Direction.Descending
        sorted_vec . should_equal small_expected

    group_builder.specify "should correctly propagate state through each" <|
        v = State.run Number 77 <|
            Vector.build builder->
                (alter ["A", "B"]).each x->
                    builder.append x
                    builder.append (State.get Number).to_text

        v.should_equal ['A', '77', 'B', '77']

    group_builder.specify "should correctly propagate state through map" <|
        v = State.run Number 55 <|
            Vector.build builder->
                (alter ["X", "Y"]).map x->
                    builder.append x
                    builder.append (State.get Number).to_text

        v.should_equal ['X', '55', 'Y', '55']

    group_builder.specify "should pad elements" <|
        alter [] . pad 3 0 . should_equal [0, 0, 0]
        alter [1, 2, 3] . pad 0 0 . should_equal [1, 2, 3]
        alter [1, 2, 3] . pad 3 0 . should_equal [1, 2, 3]
        alter [1] . pad 3 0 . should_equal [1, 0, 0]

    group_builder.specify "should zip elements" <|
        alter [1, 2, 3] . zip [] (+) . should_equal []
        alter [1, 2, 3] . zip [4] (+) . should_equal [5]
        alter [1, 2, 3] . zip [4, 5, 6] (+) . should_equal [5, 7, 9]
        alter [1, 2, 3] . zip [4, 5, 6, 7] (+) . should_equal [5, 7, 9]
        alter [] . zip [4, 5, 6] (+) . should_equal []

    group_builder.specify "should zip elements with zip on_problems=No_Wrap" <|
        alter [1, 2, 3] . zip on_problems=No_Wrap.Value [] (+) . should_equal []
        alter [1, 2, 3] . zip on_problems=No_Wrap.Value [4] (+) . should_equal [5]
        alter [1, 2, 3] . zip on_problems=No_Wrap.Value [4, 5, 6] (+) . should_equal [5, 7, 9]
        alter [1, 2, 3] . zip on_problems=No_Wrap.Value [4, 5, 6, 7] (+) . should_equal [5, 7, 9]
        alter [] . zip on_problems=No_Wrap.Value [4, 5, 6] (+) . should_equal []

    group_builder.specify "should flat_map elements" <|
        alter [1, 2, 3] . flat_map (_ -> []) . should_equal []
        alter [1, 2, 3] . flat_map (_ -> [0, 1]) . should_equal [0, 1, 0, 1, 0, 1]
        alter [1, 2, 3] . flat_map (_ -> [0, [1]]) . should_equal [0, [1], 0, [1], 0, [1]]
        alter [0, 1, 0] . flat_map (i -> if i == 1 then [1, 1] else [i]) . should_equal [0, 1, 1, 0]
        alter [0, 0, 0] . flat_map (i -> [i]) . should_equal [0, 0, 0]

    group_builder.specify "should flat_map elements with flat_map on_problems=No_Wrap" <|
        alter [1, 2, 3] . flat_map on_problems=No_Wrap.Value (_ -> []) . should_equal []
        alter [1, 2, 3] . flat_map on_problems=No_Wrap.Value (_ -> [0, 1]) . should_equal [0, 1, 0, 1, 0, 1]
        alter [1, 2, 3] . flat_map on_problems=No_Wrap.Value (_ -> [0, [1]]) . should_equal [0, [1], 0, [1], 0, [1]]
        alter [0, 1, 0] . flat_map on_problems=No_Wrap.Value (i -> if i == 1 then [1, 1] else [i]) . should_equal [0, 1, 1, 0]
        alter [0, 0, 0] . flat_map on_problems=No_Wrap.Value (i -> [i]) . should_equal [0, 0, 0]

    group_builder.specify "should allow inserting elements" <|
        alter [2, 3] . insert . should_equal [2, 3, Nothing]
        alter [2, 3] . insert item=1 . should_equal [2, 3, 1]
        alter [2, 3] . insert 100 item=1 . should_fail_with Index_Out_Of_Bounds
        alter [2, 3] . insert 0 item=1 . should_equal [1, 2, 3]
        alter [2, 3] . insert 0 . should_equal [Nothing, 2, 3]
        alter [2, 3] . insert 2 . should_equal [2, 3, Nothing]
        alter [1, 2, 3] . insert -1 item=4 . should_equal [1, 2, 4, 3]
        alter [1, 2, 3] . insert -20 item=4 . should_fail_with Index_Out_Of_Bounds

    group_builder.specify "should allow removing elements" <|
        alter [1, 2, 3] . remove . should_equal [1, 2]
        alter [1, 2, 3] . remove 100 . should_fail_with Index_Out_Of_Bounds
        alter [1, 2, 3] . remove -123 . should_fail_with Index_Out_Of_Bounds
        alter [1, 2, 3] . remove 0 . should_equal [2, 3]
        alter [1, 2, 3] . remove -1 . should_equal [1, 2]

    group_builder.specify "should return a vector containing only unique elements" <|
        alter [1, 3, 1, 2, 2, 1] . distinct . should_equal [1, 3, 2]
        alter ["a", "a", "a"] . distinct . should_equal ["a"]
        alter ['ś', 's', 's\u0301'] . distinct . should_equal ['ś', 's']
        alter [1, 1.0, 2, 2.0] . distinct . should_equal [1, 2]
        alter [] . distinct . should_equal []

    group_builder.specify "should return a vector containing duplicate elements" <|
        alter [1, 3, 1, 2, 2, 1] . duplicates . should_equal [1, 1, 2, 2, 1]
        alter ["a", "a", "a"] . duplicates . should_equal ["a", "a", "a"]
        alter ['ś', 's', 's\u0301'] . duplicates . should_equal ['ś', 's\u0301']
        alter [1, 1.0, 2, 2.0] . duplicates . should_equal [1, 1.0, 2, 2.0]
        alter [] . duplicates . should_equal []

    group_builder.specify "should be able to handle distinct on different primitive values" <|
        alter [1, "a"] . distinct . should_equal [1, "a"]
        alter ["a", 1] . distinct . should_equal ["a", 1]
        alter [Nothing, Nothing] . distinct . should_equal [Nothing]
        alter [Number.nan, Number.nan] . distinct . to_text . should_equal "[NaN]"
        alter [Nothing, Number.nan, Nothing, Number.nan] . distinct . to_text . should_equal "[Nothing, NaN]"
        alter [1, Nothing] . distinct . should_equal [1, Nothing]
        alter [Nothing, 1, Nothing] . distinct . should_equal [Nothing, 1]
        alter [1, Number.nan] . distinct . to_text . should_equal "[1, NaN]"
        alter [Number.nan, 1, Number.nan] . distinct . to_text . should_equal "[NaN, 1]"
        alter [1, Number.nan, 1] . distinct . to_text . should_equal "[1, NaN]"
        alter [Number.nan, My_Nan.Value 42, My_Nan.Value 23] . distinct . to_text . should_equal "[NaN, (My_Nan.Value 42), (My_Nan.Value 23)]"
        my_nan = My_Nan.Value 42
        alter [my_nan, Number.nan, my_nan] . distinct . to_text . should_equal "[(My_Nan.Value 42), NaN]"

    group_builder.specify "should correctly handle distinct with types that have custom comparators" <|
        alter [T.Value 1 2, T.Value 3 3, T.Value 1 2] . distinct . should_equal [T.Value 1 2, T.Value 3 3]
        alter [T.Value 1 2, T.Value 3 3, T.Value 1 2, Nothing] . distinct . should_equal [T.Value 1 2, T.Value 3 3, Nothing]
        alter [Nothing, T.Value 1 2, T.Value 3 3, T.Value 1 2, Nothing] . distinct . should_equal [Nothing, T.Value 1 2, T.Value 3 3]
        alter [T.Value 1 2, Date.new year=1973] . distinct . should_equal [T.Value 1 2, Date.new year=1973]

    group_builder.specify "should return a vector containing only unique elements up to some criteria" <|
        alter [Pair.new 1 "a", Pair.new 2 "b", Pair.new 1 "c"] . distinct (on = _.first) . should_equal [Pair.new 1 "a", Pair.new 2 "b"]

    group_builder.specify "should be able to sort a heterogenous vector" <|
        arr = alter [ 1, 1.3, "hi", Date.today, Date_Time.now, [ 0 ] ]
        (arr.sort on=(.to_text) . map .to_text) . should_equal (arr.map .to_text . sort)
        (arr.sort on=(_.to_text) . map .to_text) . should_equal (arr.map .to_text . sort)
        (arr.sort on=(x-> x.to_text) . map .to_text) . should_equal (arr.map .to_text . sort)

    group_builder.specify "should be able to sort a polyglot vector" <|
        input = "beta".utf_8
        expected = "abet".utf_8
        input.sort . should_equal expected

    group_builder.specify "should report only a limited number of warnings for incomparable values" <|
        gen x = case (x % 10) of
            0 -> Nothing
            1 -> "foo"+x.to_text
            2 -> x
            3 -> Number.nan
            4 -> Date.new
            5 -> []
            6 -> -x
            7 -> Number.nan
            8 -> Time_Of_Day.new
            _ -> x
        input = 0.up_to 500 . map gen
        sorted = input.sort on_problems=..Report_Warning
        warnings = Warning.get_all sorted
        Test.with_clue "(sorted - warnings = "+warnings.to_display_text+") " <|
            warnings.length . should_equal 10
        Warning.limit_reached sorted . should_equal True

    group_builder.specify "an error thrown inside map should be caught as a Map_Error" <|
        alter [10, 20, 30, 40] . map map_fun . should_fail_with (Map_Error.Error 2 (My_Error.Error 30)) unwrap_errors=False

    group_builder.specify "an error thrown inside map on_problems=No_Wrap should be caught as a My_Error" <|
        alter [10, 20, 30, 40] . map on_problems=No_Wrap.Value map_fun . should_fail_with My_Error

    group_builder.specify "an error thrown inside map_with_index on_problems=No_Wrap should be caught as a My_Error" <|
        map_with_index_fun _ a = if a == 30 then Error.throw (My_Error.Error a) else a+1
        alter [10, 20, 30, 40] . map_with_index on_problems=No_Wrap.Value map_with_index_fun . should_fail_with My_Error

    group_builder.specify "an error thrown inside map and caught (without error parameter) should be caught as a Map_Error" <|
        alter [10, 20, 30, 40] . map map_fun . catch . should_equal (Map_Error.Error 2 (My_Error.Error 30))

    group_builder.specify "an error thrown inside map and caught (with error parameter My_Error) should be caught as a My_Error" <|
        alter [10, 20, 30, 40] . map map_fun . catch My_Error . should_equal (My_Error.Error 30)

    group_builder.specify "an error thrown inside map and caught (with error parameter Map_Error) should be caught as a Map_Error" <|
        alter [10, 20, 30, 40] . map map_fun . catch Map_Error . should_equal (Map_Error.Error 2 (My_Error.Error 30))

    group_builder.specify "an error thrown inside flat_map should be caught as a Map_Error" <|
        vec = alter ([[10], [20], [30], [40]].map alter)
        vec.flat_map flat_map_fun . should_fail_with (Map_Error.Error 2 (My_Error.Error [30])) unwrap_errors=False

    group_builder.specify "an error thrown inside map_with_index should be caught as a Map_Error" <|
        alter [10, 20, 30, 40] . map_with_index map_with_index_fun . should_fail_with (Map_Error.Error 2 (My_Error.Error 30)) unwrap_errors=False

    group_builder.specify "an error thrown inside zip should be caught as a Map_Error" <|
        vec = alter [10, 20, 30, 40]
        vec.zip [10, 20, 30, 40] zip_fun . should_fail_with (Map_Error.Error 2 (My_Error.Error 30)) unwrap_errors=False

    group_builder.specify "an error thrown inside nested maps should be wrapped multiple times" <|
        nested_vector = Vector.fill 5 (alter [10, 20, 30, 40])
        nested_vector.map (_.map map_fun) . should_fail_with (Map_Error.Error 0 (Map_Error.Error 2 (My_Error.Error 30))) unwrap_errors=False

    group_builder.specify "nested Map_Error indicies should be in the correct order" <|
        nested_vector = [[10, 20, 30, 40], [30, 10, 20, 30]]
        expected_warnings = [(Map_Error.Error 1 (Map_Error.Error 3 (My_Error.Error 30))), (Map_Error.Error 1 (Map_Error.Error 0 (My_Error.Error 30))), (Map_Error.Error 0 (Map_Error.Error 2 (My_Error.Error 30)))]
        Warning.get_all wrap_errors=True (nested_vector.map (_.map map_fun on_problems=..Report_Warning) on_problems=..Report_Warning) . map .value . should_equal expected_warnings

    group_builder.specify "a Nothing thrown inside map should be caught as Nothing" <|
        map_fun a = if a == 30 then Error.throw Nothing else a+1
        alter [10, 20, 30, 40] . map map_fun . should_fail_with (Map_Error.Error 2 Nothing) unwrap_errors=False

    group_builder.specify "an error thrown inside map with on_problems=..Ignore should be ignored" <|
        results = alter [10, 20, 30, 40] . map map_fun on_problems=..Ignore
        results . should_equal [11, 21, Nothing, 41]
        Warning.get_all results wrap_errors=True . should_equal []

    group_builder.specify "an error thrown inside map with on_problems=..Report_Warning should be attached as a warning" <|
        result = alter [10, 20, 30, 40] . map map_fun on_problems=..Report_Warning
        result . should_equal [11, 21, Nothing, 41]
        Warning.get_all result wrap_errors=True . map .value . should_equal [Map_Error.Error 2 (My_Error.Error 30)]

    group_builder.specify "multiple errors thrown inside map with on_problems=..Report_Warning should be attached as warnings" <|
        result = alter [10, 30, 20, 30, 40, 30] . map map_fun on_problems=..Report_Warning
        result . should_equal [11, Nothing, 21, Nothing, 41, Nothing]
        Warning.get_all result wrap_errors=True . map .value . should_equal ([5, 3, 1].map i-> Map_Error.Error i (My_Error.Error 30))

    group_builder.specify "many errors thrown inside map with on_problems=..Report_Warning should be attached as warnings and an Additional_Warnings" <|
        result = alter ([10, 20] + (Vector.fill 12 30) + [40]) . map map_fun on_problems=..Report_Warning
        result . should_equal ([11, 21] + (Vector.fill 12 Nothing) + [41])
        expected_warnings_regular = 11.down_to 1 . map i-> Map_Error.Error i (My_Error.Error 30)
        expected_warnings = expected_warnings_regular + [(Additional_Warnings.Error 2)]
        Warning.get_all result wrap_errors=True . map .value . should_equal expected_warnings

    group_builder.specify "map on_problems=No_Wrap does not do error wrapping" <|
        alter [10, 20, 30, 40] . map on_problems=No_Wrap.Value map_fun . catch . should_equal (My_Error.Error 30)

    group_builder.specify "zip on_problems=No_Wrap does not do error wrapping" <|
        zip_fun a _ = if a == 30 then Error.throw (My_Error.Error a) else a+1
        arr = alter [10, 20, 30, 40]
        arr . zip on_problems=No_Wrap.Value arr zip_fun . catch . should_equal (My_Error.Error 30)

    group_builder.specify "flat_map on_problems=No_Wrap does not do error wrapping" <|
        vec = alter [1, 2, 0, 3]
        vec.flat_map on_problems=No_Wrap.Value (n-> Error.throw (My_Error.Error n)) . catch . should_equal (My_Error.Error 1)

    group_builder.specify "can transpose a vector of vectors" <|
        mat = alter [alter [0, 1, 2], alter [3, 4, 5], alter [6, 7, 8]]
        expected = alter [alter [0, 3, 6], alter [1, 4, 7], alter [2, 5, 8]]
        mat.transpose . should_equal expected

    group_builder.specify "can transpose a vector of vectors, edge cases" <|
        mat1 = alter [alter [], alter [], alter []]
        mat1.transpose . should_equal []
        mat2 = alter []
        mat2.transpose . should_equal []

    group_builder.specify "transpose throws an Illegal_Argument error if the 'matrix' has uneven rows" <|
        mat1 = alter [alter [0, 1, 2], alter [3, 5], alter [6, 7, 8]]
        mat1.transpose . should_fail_with Illegal_Argument
        mat2 = alter [alter [], alter [3, 4, 5], alter [6, 7, 8]]
        mat2.transpose . should_fail_with Illegal_Argument

add_specs suite_builder =
    suite_builder.group "Builder.new" group_builder->
        group_builder.specify "Should be able to build a vector" <|
            builder = Builder.new
            builder.append 1
            builder.append 2
            builder.append Nothing
            builder.append 3
            v = builder.to_vector
            v . should_equal [1, 2, Nothing, 3]

            builder2 = Builder.new
            v2 = builder2.to_vector
            v2 . should_equal []

            builder3 = Builder.new 20
            builder3.append 1
            v3 = builder3.to_vector
            v3 . should_equal [1]

        group_builder.specify "Builder should throw an uncaught dataflow error as a panic if it is appended with .append" <|
            builder = Builder.new
            builder.append 1
            Test.expect_panic_with matcher=Wrapped_Dataflow_Error (builder.append (Error.throw (Illegal_Argument.Error "asdf")))

        group_builder.specify "Builder should throw an uncaught error as a panic if it is appended with .append_vector_range" <|
            builder = Builder.new
            builder.append 1
            Test.expect_panic_with matcher=Wrapped_Dataflow_Error (builder.append_vector_range [1, Error.throw (Illegal_Argument.Error "asdf")])

        group_builder.specify "Builder should propagate warnings attached to an item added to the builder with .append" <|
            builder = Builder.new
            ww = Warning.attach (My_Error.Error "err") 2
            builder.append 1
            builder.append ww
            builder.append 3
            v = builder.to_vector
            v . should_equal [1, 2, 3]
            Warning.get_all v . map .value . should_equal [My_Error.Error "err"]

        group_builder.specify "Builder should propagate warnings attached to an item added to the builder with .append_vector_range" <|
            builder = Builder.new
            ww = Warning.attach (My_Error.Error "err") 21
            builder.append 1
            builder.append_vector_range [20, ww, 22]
            builder.append 3
            v = builder.to_vector
            v . should_equal [1, 20, 21, 22, 3]
            Warning.get_all v . map .value . should_equal [My_Error.Error "err"]

        group_builder.specify "empty builder.get" <|
            b = Builder.new
            e = Panic.catch Index_Out_Of_Bounds (b.at 0) err->
                err.payload
            Meta.type_of e . should_equal Index_Out_Of_Bounds
            e.index . should_equal 0
            e.length . should_equal 0

        group_builder.specify "one number builder.get" <|
            b = Builder.new
            b.append 32
            e = Panic.catch Index_Out_Of_Bounds (b.at 1) err->
                err.payload
            Meta.type_of e . should_equal Index_Out_Of_Bounds
            e.index . should_equal 1
            e.length . should_equal 1
            b.at 0 . should_equal 32

        group_builder.specify "Vector.collect lazy" <|
            seq = Fib.sequence
            seq.take 5 . should_equal [1, 1, 2, 3, 5]

        group_builder.specify "Vector.collect empty list" <|
            l = List.Nil
            v = Vector.collect l .x .xs limit=30 stop_at=(_==List.Nil)
            v . should_equal []

        group_builder.specify "Vector.collect finite" <|
            l = List.Cons 1 <| List.Cons 2 <| List.Cons 3 <| List.Nil
            v = Vector.collect l .x .xs limit=30 stop_at=(_==List.Nil)
            v . should_equal [1, 2, 3]

        group_builder.specify "example" <|
            builder = Builder.new 5
            do_build start stop =
                builder.append start
                if start >= stop then Nothing else
                    @Tail_Call do_build start+1 stop
            do_build 1 5
            builder.to_vector . should_equal [1, 2, 3, 4, 5]

    suite_builder.group "Vector.build" group_builder->
        group_builder.specify "Should be able to build a vector" <|
            v = Vector.build builder->
                builder.append 1
                builder.append 2
                builder.append Nothing
                builder.append 3
            v . should_equal [1, 2, Nothing, 3]

            v2 = Vector.build builder->
                _ = builder  # Do nothing
            v2 . should_equal []

            v3 = Vector.build initial_capacity=20 builder->
                builder.append 1
            v3 . should_equal [1]

        group_builder.specify "Should rethrow uncaught dataflow errors returned from build callback" <|
            v = Vector.build builder->
                builder.append 1
                builder.append 2
                Error.throw (Illegal_Argument.Error "asdf")
            v . should_fail_with (Illegal_Argument.Error "asdf")

        group_builder.specify "Builder should rethrow an uncaught dataflow error if it is appended with .append" <|
            v = Vector.build builder->
                builder.append 1
                builder.append (Error.throw (Illegal_Argument.Error "asdf"))
                builder.append 3
                Test.fail "should not reach here because builder is immediately interrupted on error"
            v . should_fail_with (Illegal_Argument.Error "asdf")

        group_builder.specify "Builder should rethrow an uncaught error if it is appended with .append_vector_range" <|
            v = Vector.build builder->
                builder.append 1
                builder.append_vector_range [1, Error.throw (Illegal_Argument.Error "asdf")]
                builder.append 3
                Test.fail "should not reach here because builder is immediately interrupted on error"
            v . should_fail_with (Illegal_Argument.Error "asdf")

        group_builder.specify "Builder should propagate warnings attached to an item added to the builder with .append" <|
            v = Vector.build builder->
                ww = Warning.attach (My_Error.Error "err") 2
                builder.append 1
                builder.append ww
                builder.append 3
            v . should_equal [1, 2, 3]
            Warning.get_all v . map .value . should_equal [My_Error.Error "err"]

        group_builder.specify "Builder should propagate warnings attached to an item added to the builder with .append_vector_range" <|
            v = Vector.build builder->
                ww = Warning.attach (My_Error.Error "err") 21
                builder.append 1
                builder.append_vector_range [20, ww, 22]
                builder.append 3
            v . should_equal [1, 20, 21, 22, 3]
            Warning.get_all v . map .value . should_equal [My_Error.Error "err"]

        group_builder.specify "Builder should not propagate warnings attached to an item with .append with propagate_warnings=False" <|
            v = Vector.build propagate_warnings=False builder->
                ww = Warning.attach (My_Error.Error "err") 2
                builder.append 1
                builder.append ww
                builder.append 3
            v . should_equal [1, 2, 3]
            Warning.get_all v . should_equal []

        group_builder.specify "Builder should not propagate warnings attached to an item with .append_vector_range with propagate_warnings=False" <|
            v = Vector.build propagate_warnings=False builder->
                ww = Warning.attach (My_Error.Error "err") 21
                builder.append 1
                builder.append_vector_range [20, ww, 22]
                builder.append 3
            v . should_equal [1, 20, 21, 22, 3]
            Warning.get_all v . should_equal []

        group_builder.specify ".build_multiple count must be non-negative" <|
            Vector.build_multiple -2 (_->Nothing) . should_fail_with Illegal_Argument

        group_builder.specify "example (single)" <|
            vec = Vector.build initial_capacity=5 builder->
                do_build start stop =
                    builder.append start
                    if start >= stop then Nothing else
                        @Tail_Call do_build start+1 stop
                do_build 1 5
            vec . should_equal [1, 2, 3, 4, 5]

            vec2 = Vector.build builder->
                builder.append 1
                builder.append 2
                builder.append 3
            vec2 . should_equal [1, 2, 3]

        group_builder.specify "example (vector)" <|
            vec = Vector.build builder->
                builder.append_vector_range [1, 2]
            vec . should_equal [1, 2]

        group_builder.specify "example (vector subrange)" <|
            vec = Vector.build builder->
                builder.append_vector_range [20, 30, 40, 50] 1 3
            vec . should_equal [30, 40]

        group_builder.specify "example (multiple)" <|
             vec = Vector.build_multiple 2 builders->
                 builder0 = builders.at 0
                 builder0.append 0
                 builder0.append 1
                 builder0.append 2
                 builder1 = builders.at 1
                 builder1.append 3
                 builder1.append 4
                 builder1.append 5
             vec . should_equal [[0, 1, 2], [3, 4, 5]]

    suite_builder.group "Vector/Array equality" group_builder->
        v1 = [1, 2, 3]
        a1 = v1.to_array

        v2 = [1, 2, 3]
        a2 = v2.to_array

        group_builder.specify "vector1 should be equal to vector1" <|
            v1.should_equal v1

        group_builder.specify "vector1 should be equal to vector2" <|
            v1.should_equal v2

        group_builder.specify "vector1 should be equal to array1" <|
            v1.should_equal a1

        group_builder.specify "vector1 should be equal to array2" <|
            v1.should_equal a2

        group_builder.specify "array1 should be equal to vector1" <|
            a1.should_equal v1

        group_builder.specify "array1 should be equal to vector2" <|
            a1.should_equal v2

        group_builder.specify "array1 should be equal to array1" <|
            a1.should_equal a1

        group_builder.specify "array1 should be equal to array2" <|
            a1.should_equal a2

        group_builder.specify "should have a well-defined debug-printing method" <|
            [].pretty.should_equal "[]"
            [1,2,3].pretty.should_equal "[1, 2, 3]"
            [Nothing].pretty.should_equal "[Nothing]"
            [True, False, 'a'].pretty . should_equal "[True, False, 'a']"
            [Foo.Value True].pretty . should_equal "[(Foo.Value True)]"
            [Date.new 2022 1 1].pretty . should_equal "[Date.new 2022 1 1]"

            mixed = [1, 2, 'a', (Foo.Value True), Date.new 2022 1 1, Nothing]
            mixed.pretty . should_equal "[1, 2, 'a', (Foo.Value True), Date.new 2022 1 1, Nothing]"
            Debug.eval (mixed.pretty) . should_equal [1, 2, 'a', Foo.Value True, Date.new 2022 1 1, Nothing]

    type_spec suite_builder "Use Vector as vectors" identity
    type_spec suite_builder "Use Array as vectors" (v -> v.to_array)
    type_spec suite_builder "Use Java ArrayList as vectors" v->
        arr = ArrayList.new
        v.each (x -> arr.add x)
        arr
    type_spec suite_builder "Use Array_Proxy as vectors" v->
        Array_Proxy.new v.length (ix -> v.at ix)
    type_spec suite_builder "Use a slice of an array as vectors" v->
        v2 = v+[Nothing]
        sliced_vector = v2.slice 0 v.length
        sliced_array = sliced_vector.to_array
        sliced_array



type Fib
    Number n:Integer ~next:Fib

    take self limit:Integer = Vector.collect self .n .next limit

    sequence =
        sum_two seq = Fib.Number seq.n+seq.next.n (sum_two seq.next)
        start = Fib.Number 1 <| Fib.Number 1 (sum_two start)
        start

main filter=Nothing =
    suite = Test.build suite_builder->
        add_specs suite_builder
    suite.run_with_filter filter
