private

from Standard.Base import all hiding First, Last
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument
import Standard.Base.Errors.Illegal_State.Illegal_State
import Standard.Base.Errors.Unimplemented.Unimplemented

import Standard.Table.Internal.Problem_Builder.Problem_Builder
import Standard.Table.Internal.Vector_Builder.Vector_Builder
from Standard.Table import Aggregate_Column, Column, Value_Type
from Standard.Table.Aggregate_Column.Aggregate_Column import all
from Standard.Table.Errors import Inexact_Type_Coercion

import Standard.Database.Connection.Connection.Connection
import Standard.Database.DB_Column.DB_Column
import Standard.Database.DB_Table.DB_Table
import Standard.Database.Dialect
import Standard.Database.Dialect_Flag.Dialect_Flag
import Standard.Database.Feature.Feature
import Standard.Database.Internal.Base_Generator
import Standard.Database.Internal.Common.Database_Distinct_Helper
import Standard.Database.Internal.Common.Database_Join_Helper
import Standard.Database.Internal.Error_Mapper.Error_Mapper
import Standard.Database.Internal.Internals_Access
import Standard.Database.Internal.IR.Context.Context
import Standard.Database.Internal.IR.Context.Context_Extension
import Standard.Database.Internal.IR.From_Spec.From_Spec
import Standard.Database.Internal.IR.Internal_Column.Internal_Column
import Standard.Database.Internal.IR.Nulls_Order.Nulls_Order
import Standard.Database.Internal.IR.Order_Descriptor.Order_Descriptor
import Standard.Database.Internal.IR.Query.Query
import Standard.Database.Internal.IR.SQL_Expression.SQL_Expression
import Standard.Database.Internal.IR.SQL_Join_Kind.SQL_Join_Kind
import Standard.Database.Internal.Replace_Params.Replace_Params
import Standard.Database.Internal.SQL_Type_Mapping.SQL_Type_Mapping
import Standard.Database.Internal.SQL_Type_Reference.SQL_Type_Reference
import Standard.Database.Internal.Statement_Setter.Statement_Setter
import Standard.Database.SQL.SQL_Builder
import Standard.Database.SQL.SQL_Fragment
import Standard.Database.SQL_Statement.SQL_Statement
import Standard.Database.SQL_Type.SQL_Type
from Standard.Database.Dialect import Temp_Table_Style
from Standard.Database.Errors import SQL_Error, Unsupported_Database_Operation
from Standard.Database.Internal.Base_Generator import lift_binary_op
from Standard.Database.Internal.IR.Operation_Metadata import Date_Period_Metadata
from Standard.Database.Internal.JDBC_Connection import JDBC_Connection
from Standard.Database.Internal.Statement_Setter import fill_hole_default

import project.Internal.SQLServer_Error_Mapper.SQLServer_Error_Mapper
import project.Internal.SQLServer_Type_Mapping.SQLServer_Type_Mapping

polyglot java import java.sql.Types as Java_Types
polyglot java import org.enso.database.JDBCUtils

## PRIVATE
   The dialect of SQL Server databases.
sqlserver : SQLServer_Dialect
sqlserver =
    SQLServer_Dialect.Value make_dialect_operations

## PRIVATE
   The dialect of SQL Server databases.
type SQLServer_Dialect
    ## PRIVATE
       The dialect of SQL Server databases.
    Value dialect_operations

    ## PRIVATE
       Name of the dialect.
    name : Text
    name self = sqlserver_dialect_name

    ## PRIVATE
    to_text : Text
    to_text self = "SQL_Server_Dialect"

    ## PRIVATE
       A function which generates SQL code from the internal representation
       according to the specific dialect.
    generate_sql : Query -> SQL_Statement
    generate_sql self query =
        Base_Generator.generate_query self query . build

    ## PRIVATE
       Generates SQL to truncate a table.
    generate_truncate_table_sql : Text -> SQL_Builder
    generate_truncate_table_sql self table_name =
        Base_Generator.truncate_table_truncate_table_style self table_name

    ## PRIVATE
       Generates SQL modifier for limiting the number of rows and its position in the query
    get_limit_sql_modifier : Integer -> Any
    get_limit_sql_modifier self limit =
        [150, SQL_Builder.code (" TOP " + limit.to_text + " ")]

    ## PRIVATE
       Wraps and possibly escapes the identifier so that it can be used in a
       generated query regardless of what characters it contains.
       The quotes used will depend on the dialect.
    wrap_identifier : Text -> Text
    wrap_identifier self identifier =
        Base_Generator.wrap_in_quotes identifier

    ## PRIVATE
       Generates a SQL expression for a table literal.
    make_table_literal : Vector (Vector Text) -> Vector Text -> Text -> SQL_Builder
    make_table_literal self vecs column_names as_name =
        Base_Generator.default_make_table_literal self.wrap_identifier vecs column_names as_name

    ## PRIVATE
       Prepares an ordering descriptor.

       One of the purposes of this method is to verify if the expected ordering
       settings are supported by the given database backend.

       Arguments:
       - internal_column: the column to order by.
       - sort_direction: the direction of the ordering.
       - text_ordering: If provided, specifies that the column should be treated
         as text values according to the provided ordering. For non-text types,
         it should be set to `Nothing`.
    prepare_order_descriptor : Internal_Column -> Sort_Direction -> Nothing | Text_Ordering -> Order_Descriptor
    prepare_order_descriptor self internal_column sort_direction text_ordering =
        make_order_descriptor internal_column sort_direction text_ordering

    ## PRIVATE
       Prepares a distinct operation.
    prepare_distinct : DB_Table -> Vector -> Case_Sensitivity -> Problem_Builder -> DB_Table
    prepare_distinct self table key_columns case_sensitivity problem_builder =
        table_name_deduplicator = table.connection.base_connection.table_naming_helper.create_unique_name_strategy
        table_name_deduplicator.mark_used table.name
        inner_table_alias = table_name_deduplicator.make_unique table.name+"_inner"
        setup = table.context.as_subquery inner_table_alias [table.internal_columns]
        new_columns = setup.new_columns.first
        column_mapping = Dictionary.from_vector <| new_columns.map c-> [c.name, c]
        new_key_columns = key_columns.map c-> column_mapping.at c.name
        type_mapping = self.get_type_mapping
        distinct_expressions = new_key_columns.map column->
            value_type = type_mapping.sql_type_to_value_type column.sql_type_reference.get
            Database_Distinct_Helper.make_distinct_expression case_sensitivity problem_builder column value_type
        new_context = Context.for_subquery setup.subquery . add_extension (make_distinct_extension distinct_expressions)
        table.updated_context_and_columns new_context new_columns subquery=True

    ## PRIVATE
       Returns the mapping between SQL types of this dialect and Enso
       `Value_Type`.
    get_type_mapping : SQL_Type_Mapping
    get_type_mapping self = SQLServer_Type_Mapping

    ## PRIVATE
    get_statement_setter : Statement_Setter
    get_statement_setter self =
        custom_fill_hole stmt i type_hint value = case value of
            Nothing ->
                java_type = case type_hint of
                    Nothing -> Java_Types.NULL
                    _ ->
                        ## SQLServer needs its NULLS to be typed at least for TIME.
                        type_mapping = self.get_type_mapping
                        sql_type = type_mapping.value_type_to_sql type_hint Problem_Behavior.Ignore
                        sql_type.typeid                            
                stmt.setNull i java_type
            _ : Float     -> 
                if value.is_nan || value.is_infinite then stmt.setNull i Java_Types.REAL else
                    stmt.setDouble i value
            # Fallback to default logic for everything else
            _ -> fill_hole_default stmt i type_hint value
        Statement_Setter.Value custom_fill_hole

    ## PRIVATE
    make_cast : Internal_Column -> SQL_Type -> (SQL_Expression -> SQL_Type_Reference) -> Internal_Column
    make_cast self column target_type infer_result_type_from_database_callback =
        mapping = self.get_type_mapping
        source_type = mapping.sql_type_to_value_type column.sql_type_reference.get
        target_value_type = mapping.sql_type_to_value_type target_type
        # Boolean to String casts need special handling:
        transformed_expression = case source_type.is_boolean && target_value_type.is_text of
            True ->
                SQL_Expression.Operation "IIF" [Internals_Access.column_expression column, SQL_Expression.Literal "'True'", SQL_Expression.Literal "'False'"]
            False -> Internals_Access.column_expression column
        target_type_sql_text = mapping.sql_type_to_text target_type
        new_expression = SQL_Expression.Operation "CAST" [transformed_expression, SQL_Expression.Literal target_type_sql_text]
        new_sql_type_reference = infer_result_type_from_database_callback new_expression
        Internal_Column.Value column.name new_sql_type_reference new_expression

    ## PRIVATE
    needs_execute_query_for_type_inference : Text | SQL_Statement -> Boolean
    needs_execute_query_for_type_inference self statement =
        _ = statement
        False

    ## PRIVATE
       Specifies how the database creates temp tables.
    temp_table_style : Temp_Table_Style
    temp_table_style self = Temp_Table_Style.Hash_Prefix

    ## PRIVATE
    adapt_unified_column : Internal_Column -> Value_Type -> (SQL_Expression -> SQL_Type_Reference) -> Internal_Column
    adapt_unified_column self column approximate_result_type infer_result_type_from_database_callback =
        _ = [approximate_result_type, infer_result_type_from_database_callback]
        column

    ## PRIVATE
       Add an extra cast to adjust the output type of certain operations with
       certain arguments.

       It is used when the normal type inference provided by the database engine
       needs to be adjusted.

       In most cases this method will just return the expression unchanged, it
       is used only to override the type in cases where the default one that the
       database uses is not what we want.
    cast_op_type self (op_kind:Text) (args:(Vector Internal_Column)) (expression:SQL_Expression) =
        is_int ic =
            typeid = ic.sql_type_reference.get.typeid
            typeid == Java_Types.SMALLINT || typeid == Java_Types.INTEGER || typeid == Java_Types.BIGINT

        cast_to = case op_kind of
            "AVG" ->
                if is_int (args.at 0) then "FLOAT" else Nothing
            "STDDEV_POP" ->
                if is_int (args.at 0) then "FLOAT" else Nothing
            "STDDEV_SAMP" ->
                if is_int (args.at 0) then "FLOAT" else Nothing
            _ -> Nothing

        if cast_to.is_nothing then expression else
            SQL_Expression.Operation "CAST" [expression, SQL_Expression.Literal cast_to]

    ## PRIVATE
       Add an extra cast to adjust the output type of aggregate operations.
       Some DBs do CAST(SUM(x) AS FLOAT) others do SUM(CAST(x AS FLOAT)).
    cast_aggregate_columns self op_kind:Text columns:(Vector Internal_Column) =
        SQL_Expression.Operation op_kind (columns.map c->(self.cast_op_type op_kind columns (Internals_Access.column_expression c)))

    ## PRIVATE
    prepare_fetch_types_query : SQL_Expression -> Context -> SQL_Statement
    prepare_fetch_types_query self expression context =
        Base_Generator.default_fetch_types_query self expression context

    ## PRIVATE
    generate_collate self collation_name:Text -> Text = Base_Generator.default_generate_collate collation_name quote_char=""

    ## PRIVATE
    check_aggregate_support self aggregate:Aggregate_Column -> Boolean ! Unsupported_Database_Operation =
        unsupported name =
            Error.throw (Unsupported_Database_Operation.Error name) 
        case aggregate of
            Group_By _ _ -> True
            Count _ -> True
            Count_Distinct columns _ _ ->
                if columns.length == 1 then True else
                    unsupported "Count_Distinct on multiple columns"
            Count_Not_Nothing _ _ -> True
            Count_Nothing _ _ -> True
            Count_Not_Empty _ _ -> True
            Count_Empty _ _ -> True
            Percentile _ _ _ -> unsupported "Percentile"
            Mode _ _ -> unsupported "Mode"
            First _ _ _ _ -> unsupported "First"
            Last _ _ _ _ -> unsupported "Last"
            Maximum _ _ -> True
            Minimum _ _ -> True
            Shortest _ _ -> unsupported "Shortest"
            Longest _ _ -> unsupported "Longest"
            Standard_Deviation _ _ _ -> True
            Concatenate _ _ _ _ _ _ -> True
            Sum _ _ -> True
            Average _ _ -> True
            Median _ _ -> unsupported "Median"

    ## PRIVATE
       Checks if an operation is supported by the dialect.
    is_operation_supported self operation:Text -> Boolean =
        self.dialect_operations.is_operation_supported operation

    ## PRIVATE
       Checks if a feature is supported by the dialect.
    is_feature_supported self feature:Feature -> Boolean =
        case feature of
            Feature.Select_Columns -> True
            Feature.Sort -> True
            Feature.Filter -> True
            Feature.Join -> True
            Feature.Union -> True
            Feature.Aggregate -> True
            _ -> False

    ## PRIVATE
       Checks a dialect flag
    flagged self flag:Dialect_Flag -> Boolean =
        case flag of
            Dialect_Flag.Supports_Negative_Decimal_Places -> True
            Dialect_Flag.Supports_Float_Decimal_Places -> True
            Dialect_Flag.Use_Builtin_Bankers -> False
            Dialect_Flag.Primary_Key_Allows_Nulls -> False
            Dialect_Flag.Supports_Separate_NaN -> False
            Dialect_Flag.Supports_Nested_With_Clause -> True
            Dialect_Flag.Supports_Case_Sensitive_Columns -> False
            Dialect_Flag.Supports_Infinity -> False
            Dialect_Flag.Case_Sensitive_Text_Comparison -> False
            Dialect_Flag.Supports_Sort_Digits_As_Numbers -> False
            Dialect_Flag.Supports_Case_Insensitive_Ordering -> True
            Dialect_Flag.Order_By_Unicode_Normalization_By_Default -> True
            Dialect_Flag.Order_By_Unicode_Normalization_When_Case_Insensitive -> True
            Dialect_Flag.Case_Insensitive_Ordering_By_Default -> True
            Dialect_Flag.Allows_Mixed_Type_Comparisons -> False
            Dialect_Flag.Supports_Unicode_Normalization -> False
            Dialect_Flag.NaN_Non_Comparable -> True
            Dialect_Flag.Distinct_Returns_First_Row_From_Group_If_Ordered -> True
            Dialect_Flag.Date_Time -> True
            Dialect_Flag.Text_Length_Limited_Columns -> True
            Dialect_Flag.Fixed_Length_Text_Columns -> True
            Dialect_Flag.Length_Restricted_Text_Columns -> True
            Dialect_Flag.Removes_Trailing_Whitespace_Casting_From_Char_To_Varchar -> True
            Dialect_Flag.Char_Max_Size_After_Substring_Kept -> False
            Dialect_Flag.Different_Size_Integer_Types -> True
            Dialect_Flag.Supports_8bit_Integer -> False
            Dialect_Flag.Supports_Decimal_Type -> True
            Dialect_Flag.Supports_Time_Duration -> False
            Dialect_Flag.Supports_Nanoseconds_In_Time -> False
            Dialect_Flag.Supports_Mixed_Columns -> False
            Dialect_Flag.Supports_Date_Time_Without_Timezone -> False

    ## PRIVATE
       The default table types to use when listing tables.
    default_table_types : Vector Text
    default_table_types self =
        ["TABLE", "VIEW", "TEMPORARY TABLE", "TEMPORARY VIEW", "MATERIALIZED VIEW"]

    ## PRIVATE
    get_error_mapper : Error_Mapper
    get_error_mapper self = SQLServer_Error_Mapper

    ## PRIVATE
       The dialect-dependent strategy to get the Primary Key for a given table.

       Returns `Nothing` if the key is not defined.
    fetch_primary_key : Connection -> Text -> Vector Text ! Nothing
    fetch_primary_key self connection table_name =
        Dialect.default_fetch_primary_key connection table_name

    ## PRIVATE
       Prepares metadata for an operation taking a date/time period and checks
       if the given period is supported.
    prepare_metadata_for_period : Date_Period | Time_Period -> Value_Type -> Any
    prepare_metadata_for_period self period operation_input_type =
        if period == Time_Period.Nanosecond then Error.throw (Unsupported_Database_Operation.Error "Nanosecond precision date/times") else
            Date_Period_Metadata.Value period operation_input_type

    ## PRIVATE
       Returns true if the `replace` parameters are supported by this backend.
    if_replace_params_supports : Replace_Params -> Any -> Any
    if_replace_params_supports self replace_params ~action =
        if supported_replace_params.contains replace_params then action else replace_params.throw_unsupported sqlserver_dialect_name

    ## PRIVATE
    value_type_for_upload_of_existing_column : DB_Column -> Value_Type
    value_type_for_upload_of_existing_column self column = case column of
        # Return the type as-is for database columns.
        _ : DB_Column -> column.value_type
        _ : Column ->
            base_type = column.value_type
            case base_type of
                Value_Type.Decimal precision scale ->
                    used_scale = scale.if_nothing 12
                    used_precision = Math.min 38 precision.if_nothing 38
                    new_type = Value_Type.Decimal used_precision used_scale
                    if used_scale==scale && used_precision==precision then new_type else
                        Warning.attach (Inexact_Type_Coercion.Warning base_type new_type unavailable=False) new_type
                _ -> base_type

    ## PRIVATE
    needs_literal_table_cast : Value_Type -> Boolean
    needs_literal_table_cast self value_type =
        _ = value_type
        False

    ## PRIVATE
    ensure_query_has_no_holes : JDBC_Connection -> Text -> Nothing ! Illegal_Argument
    ensure_query_has_no_holes self jdbc:JDBC_Connection raw_sql:Text =
        ## The jdbc driver doesn't work for asking about holes for SQLServer temp tables
           We can skip this check and still get a decent error message
        if raw_sql.contains "#" . not then
            jdbc.ensure_query_has_no_holes raw_sql

    ## PRIVATE
    generate_expression self base_gen expr:(SQL_Expression | Order_Descriptor | Query) for_select:Boolean -> SQL_Builder =
        if for_select then _generate_expression self base_gen expr Expression_Kind.Value materialize_null_check=True . first else
            _generate_expression self base_gen expr Expression_Kind.Boolean_Condition . first

## Returns a pair of a SQL_Builder for the given expression and a vector of columns
   that have been used in the expression and need to be checked for nulls.
   SQL Server needs special handling commpared to ther databases as it does not have a
   boolean data type.
   This means that you can write
       SELECT * FROM MyTable WHERE [Column1] > [Column2]
   but you cannot write
       SELECT [Column1] > [Column2] FROM MyTable
   to write the second query you need to write
       SELECT CASE WHEN [Column1] IS NULL OR [Column2] IS NULL WHEN [Column1] > [Column2] THEN 1 ELSE 0 END FROM MyTable
   The below function collects all of the fields which are needed to be checked for nulls returning them in a vector
   as the second element of the pair.
   The first element of the pair is the SQL_Builder for the expression.
private _generate_expression dialect base_gen expr expression_kind:Expression_Kind materialize_null_check:Boolean=False = case expr of
    SQL_Expression.Column _ _ ->
        wrapped_name = base_gen.generate_expression dialect expr
        typed_result = _align_type wrapped_name Expression_Kind.Value expression_kind
        pair typed_result [wrapped_name]
    SQL_Expression.Constant value -> 
        wrapped = case value of
            Nothing -> SQL_Builder.code "NULL"
            _ -> SQL_Builder.interpolation value
        pair wrapped [wrapped]
    SQL_Expression.Literal value ->
        modified_value = case value of
            "TRUE" -> "1"
            "FALSE" -> "0"
            _ -> value
        wrapped = _align_type (SQL_Builder.code modified_value) Expression_Kind.Value expression_kind
        pair wrapped []
    SQL_Expression.Text_Literal _ ->
        wrapped_literal = base_gen.generate_expression dialect expr
        pair wrapped_literal []
    SQL_Expression.Operation op_kind arguments metadata ->
        op = dialect.dialect_operations.operations_dict.get op_kind (Error.throw <| Unsupported_Database_Operation.Error op_kind)
        materialize_child_null_check = _op_needs_to_materialize_null_checks op_kind
        parsed_args_and_null_checks = arguments.map_with_index (i->c-> _generate_expression dialect base_gen c (_op_expected_kind op_kind i) materialize_child_null_check)
        parsed_args = parsed_args_and_null_checks.map .first
        null_checks = parsed_args_and_null_checks.map .second  . flatten

        ## In the case that we actually want to check for null then we need to generate the null
           check sql for all the columns that have been used up to this point and that 
           becomes the expression.
        expr_result = if op_kind == "IS_NULL" then _generate_is_null_expr null_checks else
            base_gen.apply_op_generator_with_metadata op parsed_args metadata
        null_checks_result = if op_kind == "IS_NULL" || materialize_child_null_check then [] else null_checks
        has_kind = _op_return_kind op_kind
        converted_expr = _align_type expr_result has_kind expression_kind
        final_expr = if materialize_null_check then _generate_null_check_sql_builder null_checks_result converted_expr else 
            converted_expr

        pair final_expr null_checks_result
    query : Query -> pair (base_gen.generate_sub_query dialect query) []
    descriptor : Order_Descriptor -> pair (base_gen.generate_order dialect descriptor) []

## PRIVATE
type Expression_Kind
    Boolean_Condition
    Value

private _align_type expr (has_kind : Expression_Kind) (expected_kind : Expression_Kind) =
    if has_kind == expected_kind then expr else
        case expected_kind of
            Expression_Kind.Boolean_Condition -> _convert_value_to_boolean_expression expr
            Expression_Kind.Value -> _convert_boolean_to_value_expression expr

private _convert_value_to_boolean_expression expr =
    expr ++ " = 1"

private _convert_boolean_to_value_expression expr =
    SQL_Builder.code "IIF(" ++ expr ++ ", CAST(1 AS BIT), CAST(0 AS BIT))"

private _generate_null_check_sql_builder null_checks:Vector expr -> SQL_Builder =
    if null_checks.length == 0 then expr else
        SQL_Builder.code "IIF(" ++ _generate_is_null_expr null_checks ++ ", NULL, " ++ expr ++ ")"

private _generate_is_null_expr null_checks:Vector -> SQL_Builder =
    (null_checks.map it->(it.paren ++ " IS NULL ")) . reduce acc-> i-> acc ++ "OR " ++ i

private _op_expected_kind op arg_pos -> Expression_Kind =
    case op of
        "NOT" -> Expression_Kind.Boolean_Condition
        "IIF" -> [Expression_Kind.Boolean_Condition, Expression_Kind.Value, Expression_Kind.Value] . at arg_pos
        _ -> Expression_Kind.Value

private _op_return_kind op -> Expression_Kind = 
    return_bool_ops = ["NOT", "BETWEEN", ">=", ">", "<=", "<", "!=", "==", "IN", "IS_NULL", "LIKE", "STARTS_WITH", "ENDS_WITH", "CONTAINS", "EQUALS_IGNORE_CASE", "IS_EMPTY"]
    if return_bool_ops.contains op then Expression_Kind.Boolean_Condition else Expression_Kind.Value

private _op_needs_to_materialize_null_checks op -> Boolean =
    ["FILL_NULL", "COALESCE", "COUNT_IS_NULL", "COUNT_EMPTY", "COUNT_NOT_EMPTY", "COUNT", "SUM", "AVG", "LONGEST", "SHORTEST", "COUNT_DISTINCT", "COUNT_DISTINCT_INCLUDE_NULL", "STDDEV_POP", "STDDEV_SAMP", "CONCAT", "CONCAT_QUOTE_IF_NEEDED", "MIN", "MAX"].contains op

## PRIVATE
make_dialect_operations =
    cases = [["LOWER", Base_Generator.make_function "LOWER"], ["UPPER", Base_Generator.make_function "UPPER"]]
    text = [starts_with, contains, ends_with, like, agg_shortest, agg_longest, make_case_sensitive, ["REPLACE", replace], left, right]+concat_ops+cases+trim_ops
    counts = [agg_count_is_null, agg_count_empty, agg_count_not_empty, ["COUNT_DISTINCT", agg_count_distinct], ["COUNT_DISTINCT_INCLUDE_NULL", agg_count_distinct_include_null]]
    arith_extensions = [floating_point_div, mod_op, decimal_div, decimal_mod, ["ROW_MIN", Base_Generator.make_function "LEAST"], ["ROW_MAX", Base_Generator.make_function "GREATEST"]]
    bool = [bool_or]

    stddev_pop = ["STDDEV_POP", Base_Generator.make_function "STDEVP"]
    stddev_samp = ["STDDEV_SAMP", Base_Generator.make_function "STDEV"]
    stats = [stddev_pop, stddev_samp]
    date_ops = [["year", Base_Generator.make_function "year"], make_datepart "quarter", ["month", Base_Generator.make_function "month"], make_datepart "week" "iso_week", ["day", Base_Generator.make_function "day"], make_datepart "hour", make_datepart "minute", make_datepart "day_of_year" "dayofyear", make_day_of_week, make_datepart "second", make_datepart "millisecond", make_extract_microsecond, ["date_add", make_date_add], ["date_diff", make_date_diff], ["date_trunc_to_day", make_date_trunc_to_day]]
    special_overrides = [is_empty, ["IIF", _make_iif]]
    other = [["RUNTIME_ERROR", make_runtime_error_op]]
    my_mappings = text + counts + arith_extensions + bool + stats + date_ops + special_overrides + other
    base = Base_Generator.base_dialect_operations . extend_with my_mappings
    Base_Generator.Dialect_Operations.Value (base.operations_dict.remove "IS_IN")

private _make_iif arguments:Vector -> SQL_Builder =
    case arguments.length of
        3 ->
            expr = arguments.at 0
            when_true = arguments.at 1
            when_false = arguments.at 2
            SQL_Builder.code "IIF(" ++ expr ++ ", " ++ when_true ++ ", " ++ when_false ++ ")"
        _ ->
            Error.throw <| Illegal_State.Error ("Invalid amount of arguments for operation IIF")

## PRIVATE
agg_count_is_null = Base_Generator.lift_unary_op "COUNT_IS_NULL" arg->
    SQL_Builder.code "COALESCE(SUM(CASE WHEN " ++ arg.paren ++ " IS NULL THEN 1 ELSE 0 END), 0)"

## PRIVATE
agg_count_empty = Base_Generator.lift_unary_op "COUNT_EMPTY" arg->
    SQL_Builder.code "COALESCE(SUM(CASE WHEN (" ++ arg.paren ++ " IS NULL) OR (" ++ arg.paren ++ " = '') THEN 1 ELSE 0 END), 0)"

## PRIVATE
agg_count_not_empty = Base_Generator.lift_unary_op "COUNT_NOT_EMPTY" arg->
    SQL_Builder.code "COALESCE(SUM(CASE WHEN (" ++ arg.paren ++ " IS NOT NULL) AND (" ++ arg.paren ++ " != '') THEN 1 ELSE 0 END), 0)"

## PRIVATE
agg_shortest = Base_Generator.lift_unary_op "SHORTEST" arg->
     SQL_Builder.code "FIRST_VALUE(" ++ arg ++ ") IGNORE NULLS OVER (ORDER BY LEN(" ++ arg ++ "))"

## PRIVATE
agg_longest = Base_Generator.lift_unary_op "LONGEST" arg->
     SQL_Builder.code "FIRST_VALUE(" ++ arg ++ ") IGNORE NULLS OVER (ORDER BY LEN(" ++ arg ++ ") DESC)"

## PRIVATE
concat_ops =
    make_raw_concat_expr expr separator =
        SQL_Builder.code "string_agg(" ++ expr ++ ", " ++ separator ++ ")"
    concat = Base_Generator.make_concat make_raw_concat_expr make_contains_expr append_char="+"
    [["CONCAT", concat (has_quote=False)], ["CONCAT_QUOTE_IF_NEEDED", concat (has_quote=True)]]

## PRIVATE
trim_ops =
    whitespace = "' ' || CHR(9) || CHR(10) || CHR(13)"
    make_fn fn_name = Base_Generator.lift_binary_op fn_name input-> chars-> case chars of
            Nothing -> SQL_Builder.code fn_name+"(" ++ input ++ ", " ++ whitespace ++ ")"
            _ ->
                case chars.is_constant of
                    True ->
                        const = chars.fragments.vec.first.object
                        if const.is_nothing || const.is_empty then SQL_Builder.code fn_name+"(" ++ input ++ ", " ++ whitespace ++ ")" else
                            SQL_Builder.code fn_name+"(" ++ input ++ ", " ++ chars ++ ")"
                    False ->
                        SQL_Builder.code "CASE WHEN " ++ chars ++ " IS NULL OR " ++ chars ++ " = '' THEN " ++ fn_name ++ "(" ++ input ++ ") ELSE " ++ fn_name ++ "(" ++ input ++ ", " ++ chars ++ ") END"
    [make_fn "TRIM", make_fn "LTRIM", make_fn "RTRIM"]

## PRIVATE
agg_count_distinct args = if args.is_empty then (Error.throw (Illegal_Argument.Error "COUNT_DISTINCT requires at least one argument.")) else
    case args.length == 1 of
        True ->
            ## A single null value will be skipped.
            SQL_Builder.code "COUNT(DISTINCT " ++ args.first ++ ")"
        False -> Error.throw (Illegal_Argument.Error "COUNT_DISTINCT supports only single arguments in SQLServer.")

## PRIVATE
agg_count_distinct_include_null args = case args.length == 1 of
    True ->
        arg = args.first
        count = SQL_Builder.code "COUNT(DISTINCT " ++ arg ++ ")"
        all_nulls_case = SQL_Builder.code "CASE WHEN COUNT(CASE WHEN " ++ arg ++ "IS NULL THEN 1 END) > 0 THEN 1 ELSE 0 END"
        count ++ " + " ++ all_nulls_case
    False -> Error.throw (Illegal_Argument.Error "COUNT_DISTINCT supports only single arguments in SQLServer.")

## PRIVATE
is_empty = Base_Generator.lift_unary_op "IS_EMPTY" arg->
    is_null = (arg ++ " IS NULL").paren
    is_empty = (SQL_Builder.code 'DATALENGTH(' ++ arg ++ ') = 0').paren
    (is_null ++ " OR " ++ is_empty).paren


## PRIVATE
starts_with = Base_Generator.lift_binary_op "STARTS_WITH" str-> sub->
    res = str ++ " LIKE (" ++ sub ++ "+'%')"
    res.paren

## PRIVATE
like = Base_Generator.lift_binary_op "LIKE" str-> sub->
    res = str ++ " LIKE (REPLACE(REPLACE(" ++ sub ++ ",'[','¬['), ']', '¬]')) ESCAPE '¬'"
    res.paren

## PRIVATE
ends_with = Base_Generator.lift_binary_op "ENDS_WITH" str-> sub->
    res = str ++ " LIKE ('%'+" ++ sub ++ ")"
    res.paren

## PRIVATE
make_contains_expr expr substring =
    SQL_Builder.code "CHARINDEX(" ++ substring ++ ", " ++ expr ++ ") > 0"

## PRIVATE
contains = Base_Generator.lift_binary_op "CONTAINS" make_contains_expr

## PRIVATE
make_case_sensitive = Base_Generator.lift_unary_op "MAKE_CASE_SENSITIVE" arg->
    SQL_Builder.code "((" ++ arg ++ ') COLLATE Latin1_General_BIN2)'

## PRIVATE
left = Base_Generator.lift_binary_op "LEFT" str-> n->
    SQL_Builder.code "left(" ++ str ++ ", CAST(" ++ n ++ " AS INT))"

## PRIVATE
right = Base_Generator.lift_binary_op "RIGHT" str-> n->
    SQL_Builder.code "right(" ++ str ++ ", CAST(" ++ n ++ " AS INT))"

## PRIVATE
make_order_descriptor internal_column sort_direction text_ordering =
    nulls = Nothing
    case text_ordering of
        Nothing ->
            Order_Descriptor.Value (Internals_Access.column_expression internal_column) sort_direction nulls_order=nulls collation=Nothing
        _ ->
            ## In the future we can modify this error to suggest using a custom defined collation.
            if text_ordering.sort_digits_as_numbers then Error.throw (Unsupported_Database_Operation.Error "sort_digits_as_numbers") else
                case text_ordering.case_sensitivity of
                    Case_Sensitivity.Default ->
                        Order_Descriptor.Value (Internals_Access.column_expression internal_column) sort_direction nulls_order=nulls collation=Nothing
                    Case_Sensitivity.Sensitive ->
                        Order_Descriptor.Value (Internals_Access.column_expression internal_column) sort_direction nulls_order=nulls collation="Latin1_General_BIN2"
                    Case_Sensitivity.Insensitive locale -> case locale == Locale.default of
                        False ->
                            Error.throw (Unsupported_Database_Operation.Error "Case insensitive ordering with custom locale")
                        True ->
                            Order_Descriptor.Value (Internals_Access.column_expression internal_column) sort_direction nulls_order=nulls collation="Latin1_General_CI_AS"

## PRIVATE
bool_or = Base_Generator.lift_unary_op "BOOL_OR" arg->
    SQL_Builder.code "bool_or(" ++ arg ++ ")"

## PRIVATE
bool_not = Base_Generator.lift_unary_op "NOT" arg->
    SQL_Builder.code "(" ++ arg ++ ")=0"

## PRIVATE
floating_point_div = Base_Generator.lift_binary_op "/" x-> y->
    SQL_Builder.code "CAST(" ++ x ++ " AS double precision) / CAST(" ++ y ++ " AS double precision)"

## PRIVATE
mod_op = Base_Generator.lift_binary_op "MOD" x-> y->
    x ++ " - FLOOR(CAST(" ++ x ++ " AS double precision) / CAST(" ++ y ++ " AS double precision)) * " ++ y

## PRIVATE
decimal_div = Base_Generator.lift_binary_op "DECIMAL_DIV" x-> y->
    SQL_Builder.code "CAST(" ++ x ++ " AS decimal) / CAST(" ++ y ++ " AS decimal)"

## PRIVATE
decimal_mod = Base_Generator.lift_binary_op "DECIMAL_MOD" x-> y->
    x ++ " - FLOOR(CAST(" ++ x ++ " AS decimal) / CAST(" ++ y ++ " AS decimal)) * " ++ y

## PRIVATE
supported_replace_params : Hashset Replace_Params
supported_replace_params =
    e0 = [Replace_Params.Value Text Case_Sensitivity.Default False, Replace_Params.Value Text Case_Sensitivity.Default True, Replace_Params.Value Text Case_Sensitivity.Sensitive False]
    e1 = [Replace_Params.Value Text Case_Sensitivity.Sensitive True, Replace_Params.Value Text Case_Sensitivity.Insensitive False, Replace_Params.Value Text Case_Sensitivity.Insensitive True]
    e2 = [Replace_Params.Value Regex Case_Sensitivity.Default False, Replace_Params.Value Regex Case_Sensitivity.Default True, Replace_Params.Value Regex Case_Sensitivity.Sensitive False]
    e3 = [Replace_Params.Value Regex Case_Sensitivity.Sensitive True, Replace_Params.Value Regex Case_Sensitivity.Insensitive False, Replace_Params.Value Regex Case_Sensitivity.Insensitive True]
    e4 = [Replace_Params.Value DB_Column Case_Sensitivity.Default False, Replace_Params.Value DB_Column Case_Sensitivity.Sensitive False]
    Hashset.from_vector <| e0 + e1 + e2 + e3 + e4

## PRIVATE
replace : Vector SQL_Builder -> Any -> SQL_Builder
replace args metadata =
    input = args.at 0
    pattern = args.at 1
    replacement = args.at 2

    ## `raw_pattern` is a `Text1 or `Regex`; it's the same value as `input`, but not
       embedded in IR.
    raw_pattern = metadata.at 0
    replace_params = metadata.at 1

    expression = case replace_params.input_type of
        Text ->
            ## To use REGEXP_REPLACE on a non-regex, we have to escape it.
            escaped_pattern = SQL_Builder.interpolation (Regex.escape raw_pattern)
            case replace_params.only_first of
                False -> case replace_params.case_sensitivity of
                    Case_Sensitivity.Insensitive _ ->
                        SQL_Builder.code "REGEXP_REPLACE(" ++ input ++ ", " ++ escaped_pattern ++ ", " ++ replacement ++ ", 'ig')"
                    _ ->
                        SQL_Builder.code "REPLACE(" ++ input ++ ", " ++ pattern ++ ", " ++ replacement ++ ")"
                True -> case replace_params.case_sensitivity of
                    Case_Sensitivity.Insensitive _ ->
                        SQL_Builder.code "REGEXP_REPLACE(" ++ input ++ ", " ++ escaped_pattern ++ ", " ++ replacement ++ ", 'i')"
                    _ ->
                        SQL_Builder.code "REGEXP_REPLACE(" ++ input ++ ", " ++ escaped_pattern ++ ", " ++ replacement ++ ")"
        Regex ->
            pattern_string = SQL_Builder.interpolation raw_pattern.pattern_string
            case replace_params.only_first of
                False -> case replace_params.case_sensitivity of
                    Case_Sensitivity.Insensitive _ ->
                        SQL_Builder.code "REGEXP_REPLACE(" ++ input ++ ", " ++ pattern_string ++ ", " ++ replacement ++ ", 'ig')"
                    _ ->
                        SQL_Builder.code "REGEXP_REPLACE(" ++ input ++ ", " ++ pattern_string ++ ", " ++ replacement ++ ", 'g')"
                True -> case replace_params.case_sensitivity of
                    Case_Sensitivity.Insensitive _ ->
                        SQL_Builder.code "REGEXP_REPLACE(" ++ input ++ ", " ++ pattern_string ++ ", " ++ replacement ++ ", 'i')"
                    _ ->
                        SQL_Builder.code "REGEXP_REPLACE(" ++ input ++ ", " ++ pattern_string ++ ", " ++ replacement ++ ")"
        DB_Column ->
            case replace_params.only_first of
                False -> case replace_params.case_sensitivity of
                    Case_Sensitivity.Insensitive _ ->
                        Nothing
                    _ ->
                        SQL_Builder.code "REPLACE(" ++ input ++ ", " ++ pattern ++ ", " ++ replacement ++ ")"
                True -> Nothing
    expression.if_nothing (replace_params.throw_unsupported sqlserver_dialect_name)

make_datepart enso_name sql_name=enso_name =
    Base_Generator.lift_unary_op enso_name arg->
        SQL_Builder.code "DATEPART(" ++ sql_name ++ ", " ++ arg ++ ")"

make_day_of_week =
    Base_Generator.lift_unary_op "day_of_week" arg->
        SQL_Builder.code "((DATEPART(weekday, " ++ arg ++ ") + @@DATEFIRST - 2) % 7) + 1"

make_extract_microsecond =
    Base_Generator.lift_unary_op "microsecond" arg->
        SQL_Builder.code "DATEPART(microsecond, " ++ arg ++ ")%1000"

private _get_sqlserver_interval interval:Date_Period|Time_Period -> Text =
    case interval of
        Date_Period.Year -> "year"
        Date_Period.Quarter -> "quarter"
        Date_Period.Month -> "month"
        Date_Period.Week _ -> "week"
        Date_Period.Day -> "day"
        Time_Period.Hour -> "hour"
        Time_Period.Minute -> "minute"
        Time_Period.Second -> "second"
        Time_Period.Millisecond -> "millisecond"
        Time_Period.Microsecond -> "microsecond"
        Time_Period.Nanosecond -> "nanosecond"

## PRIVATE
make_date_add arguments (metadata : Date_Period_Metadata) =
    if arguments.length != 2 then Error.throw (Illegal_State.Error "date_add expects exactly 2 sub expressions. This is a bug in Database library.") else
        expr = arguments.at 0
        amount = arguments.at 1
        interval = _get_sqlserver_interval metadata.period
        SQL_Builder.code "DATEADD(" ++  interval ++ ", " ++ amount ++ ", " ++  expr ++ ")"

## PRIVATE
make_date_diff arguments (metadata : Date_Period_Metadata) =
    if arguments.length != 2 then Error.throw (Illegal_State.Error "date_diff expects exactly 2 sub expressions. This is a bug in Database library.") else
        start = arguments.at 0
        end = arguments.at 1
        interval = _get_sqlserver_interval metadata.period

        case metadata.period of
            ## SQLServer's DATEDIFF does not take the day of the month into account when
               calculating the month or quarter difference between two dates. To match the 
               in-memory version we have to do some extra calculations.
            Date_Period.Month   -> _make_month_datediff start end
            Date_Period.Quarter -> ((_make_month_datediff start end) ++ " / 3").paren
            _ -> SQL_Builder.code "DATEDIFF_BIG(" ++  interval ++ ", " ++ start ++ ", " ++  end ++ ")"

private _make_month_datediff start end -> SQL_Builder =
    sqlserver_month_diff = SQL_Builder.code "DATEDIFF(month, " ++ start ++ ", " ++  end ++ ")"
    day_of_month_diff = SQL_Builder.code "DAY(" ++ start ++ ") - DAY(" ++ end ++ ")"
    adjustment_amount = SQL_Builder.code "IIF(SIGN(" ++ sqlserver_month_diff ++ ")!=SIGN(" ++ day_of_month_diff ++ "), 0, SIGN(" ++ day_of_month_diff ++ "))"
    SQL_Builder.code "IIF(" ++ sqlserver_month_diff ++ "=0, 0," ++ sqlserver_month_diff ++ " - " ++ adjustment_amount ++ ")"

## PRIVATE
make_date_trunc_to_day arguments =
    if arguments.length != 1 then Error.throw (Illegal_State.Error "date_trunc_to_day expects exactly one sub expression. This is a bug in Database library.") else
        expr = arguments.at 0
        SQL_Builder.code "(DATE_TRUNC('day'," ++ expr ++ ") :: DATE)"

## PRIVATE
   The RUNTIME_ERROR operation should allow the query to compile fine and it
   will not prevent it from running if the branch including this operation is
   not taken. But if the branch is computed, it should ensure the query fails.

   This query never returns a value, so its type should be polymorphic. However,
   that is not possible - so currently it just 'pretends' that it would return a
   Boolean - because that is the type we expect in the use-case. This can be
   altered if needed.

   It takes a variable as the second argument. It can be any value that is not
   statically known - this ensure that the optimizer will not be able to
   pre-compute the expression too early (which could make the query fail
   spuriously). See `make_invariant_check` in `Lookup_Query_Helper` for an
   example.
make_runtime_error_op arguments =
    if arguments.length != 2 then
        Panic.throw (Illegal_Argument.Error "RUNTIME_ERROR takes exactly 2 arguments (error message and a variable to ensure deferred execution).")
    error_message = arguments.at 0
    variable_to_defer = arguments.at 1

    SQL_Builder.code "CAST('[ENSO INVARIANT VIOLATED: '||" ++ error_message ++ "||'] '||COALESCE(" ++ variable_to_defer ++ "::TEXT,'NULL') AS BOOLEAN)"

## PRIVATE
make_distinct_extension expressions =
    run_generator sql_expressions =
        SQL_Builder.code "DISTINCT ON (" ++ (SQL_Builder.join ", " sql_expressions) ++ ") "
    Context_Extension.Value position=120 expressions=expressions run_generator=run_generator

## PRIVATE
sqlserver_dialect_name = "SQL Server"
