from Standard.Base import all
import Standard.Base.Data.Vector.No_Wrap
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument
from Standard.Base.Runtime import assert

import project.Column.Column
import project.Internal.Problem_Builder.Problem_Builder
import project.Internal.Storage
import project.Value_Type.Auto
import project.Value_Type.Bits
import project.Value_Type.Value_Type
from project.Errors import Invalid_Value_Type, Mixing_Date_Time_Types, No_Common_Type
from project.Internal.Table_Helpers import is_column

polyglot java import org.enso.base.polyglot.NumericConverter
polyglot java import org.enso.table.data.column.storage.type.IntegerType

## PRIVATE
   Finds the most specific `Value_Type` that can be used to hold the given
   value.

   This method will still prefer default types used in the in-memory backend, so
   for integers it will return 64-bit integers even if the value could fit in a
   smaller one; and for Text values variable-length text will be preferred over
   fixed-length.
most_specific_value_type value:Any use_smallest:Boolean=False -> Value_Type =
    case value of
        Nothing         -> Value_Type.Null
        _ : Float       -> Value_Type.Float Bits.Bits_64
        _ : Decimal     -> Value_Type.Decimal
        _ : Boolean     -> Value_Type.Boolean
        _ : Date        -> Value_Type.Date
        _ : Time_Of_Day -> Value_Type.Time
        _ : Date_Time   -> Value_Type.Date_Time
        i : Integer     ->
            case NumericConverter.isBigInteger i of
                False -> case use_smallest of
                    False -> Value_Type.Integer Bits.Bits_64
                    True ->
                        storage_type = IntegerType.smallestFitting i
                        value_type = Storage.to_value_type storage_type
                        # We do a small rewrite here - for integers we always return the Integer type, even if the value is small enough to fit in a Byte.
                        if value_type == Value_Type.Byte then Value_Type.Integer Bits.Bits_16 else value_type
                True -> Value_Type.Decimal precision=Nothing scale=0
        text : Text     ->
            length = text.length
            case use_smallest of
                False -> Value_Type.Char size=Nothing variable_length=True
                True ->
                    case length > 0 of
                        True  -> Value_Type.Char size=length variable_length=False
                        # Not using Char size=0 for empty strings, because that would be an invalid value.
                        False -> Value_Type.Char size=1 variable_length=True

        ## TODO [RW] once we add Enso Native Object Type Value Type, we probably
           want to prefer it over Mixed
        _               -> Value_Type.Mixed

## PRIVATE
   Finds a type that can fit both a current type and a new type.
reconcile_types current:Value_Type new:Value_Type -> Value_Type = 
    if current == Value_Type.Null then new else if new == Value_Type.Null then current else case current of
        Value_Type.Mixed -> Value_Type.Mixed
        Value_Type.Integer size -> case new of
            Value_Type.Integer new_size ->
                Value_Type.Integer (max_size size new_size)
            Value_Type.Byte    -> current
            # If we unify integers with floats, we select the default Float 64 regardless of the input sizes.
            Value_Type.Float _     -> Value_Type.Float
            Value_Type.Decimal _ _ -> new
            _                      -> Value_Type.Mixed
        Value_Type.Float size -> case new of
            Value_Type.Float new_size ->
                Value_Type.Float (max_size size new_size)
            # If we unify integers with floats, we select the default Float 64 regardless of the input sizes.
            Value_Type.Integer _   -> Value_Type.Float
            Value_Type.Byte        -> Value_Type.Float
            Value_Type.Decimal _ _ -> Value_Type.Float
            _                      -> Value_Type.Mixed
        Value_Type.Byte -> case new of
            Value_Type.Byte        -> Value_Type.Byte
            Value_Type.Integer _   -> new
            Value_Type.Float _     -> Value_Type.Float
            Value_Type.Decimal _ _ -> new
            _                      -> Value_Type.Mixed
        Value_Type.Decimal precision scale -> case new of
            Value_Type.Decimal new_precision new_scale ->
                if (precision == new_precision) && (scale == new_scale) then new else
                    # TODO at some point we may want a more clever merging of precision and scale, for now we don't use them too much anyway so we just default to Nothing if they do not agree
                    Value_Type.Decimal
            Value_Type.Integer _ -> Value_Type.Decimal precision scale
            Value_Type.Byte      -> Value_Type.Decimal precision scale
            Value_Type.Float _   -> Value_Type.Float
            _                    -> Value_Type.Mixed
        Value_Type.Char current_size current_variable -> case new of
            Value_Type.Char new_size new_variable ->
                result_variable = current_variable || new_variable || current_size != new_size
                result_size = max_size current_size new_size
                Value_Type.Char result_size result_variable
            _ -> Value_Type.Mixed
        Value_Type.Binary current_size current_variable -> case new of
            Value_Type.Binary new_size new_variable ->
                result_variable = current_variable || new_variable || current_size != new_size
                result_size = max_size current_size new_size
                Value_Type.Binary result_size result_variable
            _ -> Value_Type.Mixed
        _ ->
            if current == new then current else Value_Type.Mixed

## PRIVATE
   Reconciles two size parameters. If either of them is `Nothing` (meaning
   unbounded), returns `Nothing`. If both are bounded, the larger one is
   returned.
max_size a b =
    if a.is_nothing || b.is_nothing then Nothing else
        if a < b then b else a

## PRIVATE
   Finds the most specific value type that will fit all the provided types.

   Arguments:
   - types: a vector of types to unify.
   - strict: A flag determining how strict the unification is.
     If `False`, if no common type can be found, `Mixed` is used as a generic fallback.
     If `True`, `Nothing` is returned if no common type can be found and `Mixed`
     is only returned if any of the input types was already `Mixed`.
find_common_type (types : Vector Value_Type) (strict : Boolean) -> Value_Type | Nothing =
    if types.is_empty then Value_Type.Null else
        most_generic_type = (types.drop 1).fold types.first reconcile_types
        if strict.not || most_generic_type != Value_Type.Mixed then most_generic_type else
            ## We return the Mixed type only if the input contained Mixed.
               Otherwise we report failure to find common type.
            if types.contains Value_Type.Mixed then Value_Type.Mixed else
                Nothing

## PRIVATE
   An extra helper function that reconciles Date_Time types with varying timezone
   setting, as well as Date type, reporting any warnings.
   It can be used as a fallback after `find_common_type` does not find a simple common type.
   If non-date types are provided, it will fail by returning `Nothing`. It will not report any warnings in that case.
   It assumes that the list of `types` is not empty.
find_common_date_types (types : Vector Value_Type) (related_column_name : Text | Nothing) (problem_builder : Problem_Builder) -> Value_Type | Nothing =
    assert types.not_empty
    all_date = types.all typ-> case typ of
        Value_Type.Date        -> True
        Value_Type.Date_Time _ -> True
        _                      -> False
    if all_date.not then Nothing else
        has_date = types.contains Value_Type.Date
        has_date_time_with_tz = types.contains (Value_Type.Date_Time True)
        has_date_time_without_tz = types.contains (Value_Type.Date_Time False)

        # The common type is the 'largest' one.
        common_type = if has_date_time_with_tz then Value_Type.Date_Time True else
            if has_date_time_without_tz then Value_Type.Date_Time False else
                Value_Type.Date

        if has_date && (common_type != Value_Type.Date) then
            problem_builder.report_other_warning (Mixing_Date_Time_Types.Date_To_Date_Time related_column_name)

        if has_date_time_without_tz && (common_type != Value_Type.Date_Time False) then
            problem_builder.report_other_warning (Mixing_Date_Time_Types.Implicit_Time_Zone related_column_name)

        common_type

## PRIVATE
   An extra helper function that reconciles numeric and boolean types.
   Unifying Boolean and numeric types is not expected by all operations, but
   some may want to opt-in to it. This method allows to do so.

   If non-numeric or non-boolean types are provided, it will fail by returning
   `Nothing`.

   No warnings are reported, as coercing boolean to integer is harmless, it was
   just chosen not to be done by default.
find_common_numeric_boolean_type (types : Vector Value_Type) -> Value_Type | Nothing =
    assert types.not_empty
    all_numeric_or_boolean = types.all typ-> typ.is_numeric || (typ == Value_Type.Boolean)
    if all_numeric_or_boolean.not then Nothing else
        ## We just find a common type again, ignoring the boolean types: the
           boolean will fit any numeric type that we get out of this.
        without_boolean = types.filter typ-> typ != Value_Type.Boolean
        find_common_type without_boolean strict=True

## PRIVATE
   Finds the type of an argument to a column operation.

   If the argument is a column, the type of that column is returned. If it
   is an Enso value, the smallest `Value_Type` that can fit that value will
   be returned (but the Database is free to widen it to the closest type
   that it supports without warning).

   Since there is no special type for `Nothing` and `Nothing` technically
   can fit any nullable type, it usually needs to be handled specially. This
   method returns `Nothing` if the value is `Nothing` - so the caller can
   try to treat this value as fitting any type, or accordingly to specific
   semantics of each method.
find_argument_type value:Any infer_precise_type:Boolean=True -> Value_Type =
    case is_column value of
        False -> most_specific_value_type value use_smallest=True
        True ->
            col_type = value.value_type
            if infer_precise_type && col_type == Value_Type.Mixed then value.inferred_precise_value_type else col_type

## PRIVATE
type Addition_Kind
    ## PRIVATE
    Numeric_Add

    ## PRIVATE
    Text_Concat

## Returns the operation kind based on types of the inputs, or an error if the inferred kinds are incompatible.
   If both inputs are Null, it is impossible to tell the kind, so Nothing is returned and the caller may decide what to do.
private resolve_operation_kind arg1:Any arg2:Any operation_name:Text find_operation_kind:(Value_Type -> Any) -> Any | Nothing =
    kinds = [arg1, arg2]
        . map on_problems=No_Wrap.Value find_operation_kind
        . filter ..Not_Nothing
        . distinct
    if kinds.is_empty then Nothing else
        if kinds.length > 1 then Error.throw (Illegal_Argument.Error ("Cannot perform "+operation_name+" on a pair of values of types " + (find_argument_type arg1).to_display_text + " and " + (find_argument_type arg2).to_display_text + ".")) else
            kinds.first

## PRIVATE
   A helper which resolves if numeric addition or string concatenation should be
   used when the a `+` operator is used with the two provided types.
   It will return an error if the provided types are incompatible.
resolve_addition_kind arg1 arg2 -> Addition_Kind | Nothing =
    find_addition_kind arg =
        typ = find_argument_type arg
        if typ.is_null then Nothing else
            if typ.is_text then Addition_Kind.Text_Concat else
                if typ.is_numeric then Addition_Kind.Numeric_Add else
                    raise_unexpected_type "numeric or text" arg
    resolve_operation_kind arg1 arg2 "addition" find_addition_kind

## PRIVATE
type Subtraction_Kind
    ## PRIVATE
    Numeric_Subtract

    ## PRIVATE
    Date_Time_Difference

## PRIVATE
   A helper which resolves if numeric subtraction or date-time difference should
   be used when the a `-` operator is used with the two provided types.
   It will return an error if the provided types are incompatible.
resolve_subtraction_kind arg1 arg2 -> Subtraction_Kind | Nothing =
    find_subtraction_kind arg =
        typ = find_argument_type arg
        if typ.is_null then Nothing else
            if typ.is_numeric then Subtraction_Kind.Numeric_Subtract else
                if typ.is_date_or_time then Subtraction_Kind.Date_Time_Difference else
                    raise_unexpected_type "numeric or date/time" arg
    kind = resolve_operation_kind arg1 arg2 "subtraction" find_subtraction_kind
    case kind of
        # Additional special logic needed:
        Subtraction_Kind.Date_Time_Difference ->
            types = [arg1, arg2].map find_argument_type . filter (!= Value_Type.Null) . distinct
            # If both types are date-time but they differ, we say second one should be the same as first.
            if types.length > 1 then raise_unexpected_type types.first arg2 else kind
        _ -> kind

## PRIVATE
   Checks that both provided arguments have numeric type and runs the action
   if they do.
check_binary_numeric_op arg1 arg2 ~action =
    Value_Type.expect_numeric arg1 <|
        Value_Type.expect_numeric arg2 <|
            action

## PRIVATE
   Checks that both provided arguments have boolean type and runs the action
   if they do.
check_binary_boolean_op arg1 arg2 ~action =
    Value_Type.expect_boolean arg1 <|
        Value_Type.expect_boolean arg2 <|
            action

## PRIVATE
   Checks that all provided argument are comparable with the provided
   column.

   Arguments:
   - column: the column to compare the arguments to.
   - arg_or_args: a single value or column or a vector of values or columns.
   - action: the action to run if the arguments are compatible.
check_multi_argument_comparable_op column arg_or_args ~action =
    args = Vector.unify_vector_or_element arg_or_args
    checked = args.map on_problems=No_Wrap.Value arg->
        Value_Type.expect_comparable column arg <|
            True
    checked.if_not_error <|
        action

## PRIVATE
raise_unexpected_type expected_type argument =
    error = case is_column argument of
        True ->
            Invalid_Value_Type.Column expected_type argument.value_type argument.name
        False ->
            Invalid_Value_Type.Value expected_type (find_argument_type argument) argument
    Error.throw error

## PRIVATE
find_common_type_for_arguments : Vector Any -> Value_Type | Nothing ! No_Common_Type
find_common_type_for_arguments arguments =
    # Here we do not want to infer the more precise type for a Mixed column, because we want it to stay Mixed.
    types = arguments.map (find_argument_type infer_precise_type=False)
    case find_common_type types strict=True of
        common_type : Value_Type -> common_type
        Nothing -> Error.throw <|
            No_Common_Type.Error types related_column_name=Nothing
